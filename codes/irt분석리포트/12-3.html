<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>한국어능력시험 시간 관리 전략 가이드</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="report-styles.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <style>
      .pie-chart {
        width: 400px;
        height: 400px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>한국어능력시험 시간 관리 전략 가이드</h1>

      <div class="section">
        <h2>1. 시험 시간 개요</h2>
        <p>
          한국어능력시험은 필기시험 75분, 구술시험 25분으로 총 100분 동안
          진행됩니다. 효과적인 시간 관리는 시험 성적 향상에 중요한 역할을
          합니다. 이 가이드에서는 시험의 각 섹션별 권장 시간 배분과 효과적인
          시간 관리 전략을 제시합니다.
        </p>
      </div>

      <div class="section">
        <h2>2. 섹션별 시간 배분</h2>
        <div id="sectionTimeAllocation"></div>
        <div id="sectionTimePie" class="pie-chart"></div>
        <p>
          위 차트는 시험의 각 섹션별 권장 시간 배분을 보여줍니다. 왼쪽의 막대
          그래프는 각 섹션의 절대적인 시간을, 오른쪽의 원형 차트는 전체 시험
          시간 중 각 섹션이 차지하는 비율을 나타냅니다. 이를 참고하여 전체 시험
          시간을 효율적으로 사용하세요.
        </p>
      </div>

      <div class="section">
        <h2>3. 문항 유형별 권장 소요 시간</h2>
        <div id="questionTypeTime"></div>
        <table id="questionTypeTimeTable">
          <thead>
            <tr>
              <th>문항 유형</th>
              <th>평균 소요 시간 (분)</th>
              <th>문항 수</th>
            </tr>
          </thead>
          <tbody>
            <!-- 여기에 JavaScript로 데이터를 채웁니다 -->
          </tbody>
        </table>
        <p>
          각 문항 유형별 평균 소요 시간을 참고하여 시간을 배분하세요. 위의
          차트와 표는 각 문항 유형에 대한 평균 소요 시간과 문항 수를 보여줍니다.
          특정 유형에 시간을 과도하게 소비하지 않도록 주의하는 것이 중요합니다.
        </p>
      </div>

      <div class="section">
        <h2>4. 효과적인 시간 관리 전략</h2>
        <h3>전체 시험 시간 배분 방법:</h3>
        <ul>
          <li>시험 시작 전 각 섹션에 할당할 시간을 미리 계획하세요.</li>
          <li>
            각 섹션이 끝날 때마다 남은 시간을 확인하고 필요하다면 계획을
            조정하세요.
          </li>
          <li>마지막 5분은 답안 검토에 할애하세요.</li>
        </ul>
        <h3>문항 유형별 접근 전략:</h3>
        <ul>
          <li>
            객관식 문항: 평균 30초 이내에 답을 고르세요. 확신이 없다면
            표시해두고 나중에 돌아오세요.
          </li>
          <li>
            주관식 문항: 평균 1분 이내로 답변을 작성하세요. 긴 답변이 필요한
            경우 핵심 단어를 먼저 적고 나중에 보완하세요.
          </li>
          <li>
            읽기 문항: 지문을 꼼꼼히 읽되, 평균 2분 이상 소요되지 않도록 하세요.
            필요한 정보를 빠르게 찾는 연습을 하세요.
          </li>
        </ul>
      </div>

      <div class="section">
        <h2>5. 시간 절약을 위한 팁</h2>
        <ul>
          <li>
            문제를 읽기 전에 보기를 먼저 훑어보세요. 이는 필요한 정보에 집중하는
            데 도움이 됩니다.
          </li>
          <li>
            어려운 문제에 막혔을 때는 과감히 다음 문제로 넘어가세요. 시간이
            남으면 다시 돌아올 수 있습니다.
          </li>
          <li>
            주기적으로 시계를 확인하되, 너무 자주 확인하여 집중력을 흐트러뜨리지
            않도록 주의하세요.
          </li>
          <li>
            빠른 읽기 기술을 연습하세요. 핵심 단어와 문장에 집중하는 습관을
            들이세요.
          </li>
        </ul>
      </div>

      <div class="section">
        <h2>6. 연습 문제 및 타이머 사용법</h2>
        <p>
          실전과 유사한 환경에서 연습하는 것이 중요합니다. 다음과 같은 방법으로
          시간 관리 능력을 향상시킬 수 있습니다:
        </p>
        <ul>
          <li>
            공식 한국어능력시험 웹사이트에서 제공하는 모의고사를 활용하세요.
          </li>
          <li>연습 시 항상 타이머를 사용하여 시간 감각을 익히세요.</li>
          <li>
            섹션별로 시간을 측정하고, 실제 시험에서의 시간 배분 계획을 세우세요.
          </li>
          <li>
            연습 후에는 시간 관리가 잘 된 부분과 개선이 필요한 부분을
            분석하세요.
          </li>
        </ul>
      </div>
    </div>

    <footer>
      <p>
        본 프로파일은 2024년 9월 기준으로 작성되었습니다. 향후 시험 정책 변경에
        따라 내용이 수정될 수 있습니다.
      </p>
    </footer>
    <script type="module">
      import {
        df_questions as _df_questions,
        df_responses,
        df_questions_speaking as _df_questions_speaking,
        df_responses_speaking,
        speaking_grading_criteria,
      } from "./data2.js";

      const df_questions = _df_questions.map((q) => {
        q.난이도 = parseFloat(q.난이도);
        q.변별도 = parseFloat(q.변별도);
        return q;
      });
      const df_questions_speaking = _df_questions_speaking.map((q) => {
        q.난이도 = parseFloat(q.난이도);
        q.변별도 = parseFloat(q.변별도);
        return q;
      });

      // 섹션별 시간 배분 데이터 계산
      const totalQuestions = df_questions.length;
      const totalTime = 75; // 필기시험 총 시간 (분)
      const averageTimePerQuestion = totalTime / totalQuestions;

      const sectionTimeData = [
        { section: "어휘", time: 0 },
        { section: "문법", time: 0 },
        { section: "쓰기", time: 0 },
        { section: "읽기", time: 0 },
        { section: "문화", time: 0 },
      ];

      df_questions.forEach((q) => {
        const index = sectionTimeData.findIndex(
          (s) => s.section === q.평가영역
        );
        if (index !== -1) {
          sectionTimeData[index].time += averageTimePerQuestion;
        }
      });

      sectionTimeData.forEach((s) => {
        s.time = Math.round(s.time);
      });

      // 섹션별 시간 배분 막대 차트
      const margin = { top: 20, right: 30, bottom: 40, left: 90 },
        width = 460 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;

      const svg = d3
        .select("#sectionTimeAllocation")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      const x = d3
        .scaleLinear()
        .domain([0, d3.max(sectionTimeData, (d) => d.time)])
        .range([0, width]);

      svg
        .append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x))
        .selectAll("text")
        .attr("transform", "translate(-10,0)rotate(-45)")
        .style("text-anchor", "end");

      const y = d3
        .scaleBand()
        .range([0, height])
        .domain(sectionTimeData.map((d) => d.section))
        .padding(0.1);

      svg.append("g").call(d3.axisLeft(y));

      svg
        .selectAll("myRect")
        .data(sectionTimeData)
        .join("rect")
        .attr("x", x(0))
        .attr("y", (d) => y(d.section))
        .attr("width", (d) => x(d.time))
        .attr("height", y.bandwidth())
        .attr("fill", "#69b3a2");

      svg
        .append("text")
        .attr("text-anchor", "end")
        .attr("x", width)
        .attr("y", height + margin.top + 20)
        .text("권장 시간 (분)");

      svg
        .append("text")
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left + 20)
        .attr("x", -margin.top)
        .text("시험 섹션");

      // 섹션별 시간 배분 원형 차트
      const pieWidth = 400;
      const pieHeight = 400;
      const radius = Math.min(pieWidth, pieHeight) / 2;

      const color = d3
        .scaleOrdinal()
        .domain(sectionTimeData.map((d) => d.section))
        .range(d3.schemeCategory10);

      const pie = d3.pie().value((d) => d.time);

      const arc = d3.arc().innerRadius(0).outerRadius(radius);

      const pieSvg = d3
        .select("#sectionTimePie")
        .append("svg")
        .attr("width", pieWidth)
        .attr("height", pieHeight)
        .append("g")
        .attr("transform", `translate(${pieWidth / 2}, ${pieHeight / 2})`);

      const arcs = pieSvg
        .selectAll("arc")
        .data(pie(sectionTimeData))
        .enter()
        .append("g");

      arcs
        .append("path")
        .attr("d", arc)
        .attr("fill", (d) => color(d.data.section));

      arcs
        .append("text")
        .attr("transform", (d) => `translate(${arc.centroid(d)})`)
        .attr("text-anchor", "middle")
        .text(
          (d) =>
            `${d.data.section} ${Math.round((d.data.time / totalTime) * 100)}%`
        );

      // 문항 유형별 권장 소요 시간 데이터 계산
      const questionTypeTimeData = [
        { type: "객관식", time: 0, count: 0 },
        { type: "단답형", time: 0, count: 0 },
      ];

      df_questions.forEach((q) => {
        const index = questionTypeTimeData.findIndex(
          (t) => t.type === q.문항유형
        );
        if (index !== -1) {
          questionTypeTimeData[index].time += averageTimePerQuestion;
          questionTypeTimeData[index].count += 1;
        }
      });

      questionTypeTimeData.forEach((t) => {
        t.time = Math.round((t.time / t.count) * 10) / 10; // 평균 시간을 계산하고 소수점 첫째 자리까지 반올림
      });

      // 문항 유형별 권장 소요 시간 차트
      const svg2 = d3
        .select("#questionTypeTime")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

      const x2 = d3
        .scaleLinear()
        .domain([0, d3.max(questionTypeTimeData, (d) => d.time)])
        .range([0, width]);

      svg2
        .append("g")
        .attr("transform", `translate(0,${height})`)
        .call(d3.axisBottom(x2))
        .selectAll("text")
        .attr("transform", "translate(-10,0)rotate(-45)")
        .style("text-anchor", "end");

      const y2 = d3
        .scaleBand()
        .range([0, height])
        .domain(questionTypeTimeData.map((d) => d.type))
        .padding(0.1);

      svg2.append("g").call(d3.axisLeft(y2));

      svg2
        .selectAll("myRect")
        .data(questionTypeTimeData)
        .join("rect")
        .attr("x", x2(0))
        .attr("y", (d) => y2(d.type))
        .attr("width", (d) => x2(d.time))
        .attr("height", y2.bandwidth())
        .attr("fill", "#4CAF50");

      svg2
        .append("text")
        .attr("text-anchor", "end")
        .attr("x", width)
        .attr("y", height + margin.top + 20)
        .text("평균 소요 시간 (분)");

      svg2
        .append("text")
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left + 20)
        .attr("x", -margin.top)
        .text("문항 유형");

      // 문항 유형별 개수 표시
      svg2
        .selectAll(".text-count")
        .data(questionTypeTimeData)
        .enter()
        .append("text")
        .attr("class", "text-count")
        .attr("x", (d) => x2(d.time) + 5)
        .attr("y", (d) => y2(d.type) + y2.bandwidth() / 2)
        .attr("dy", ".35em")
        .text((d) => `(${d.count}문항)`);

      // 문항 유형별 권장 시간 표 생성
      const table = document.getElementById("questionTypeTimeTable");
      const tbody = table.querySelector("tbody");
      questionTypeTimeData.forEach((d) => {
        const row = tbody.insertRow();
        row.insertCell(0).textContent = d.type;
        row.insertCell(1).textContent = d.time.toFixed(1);
        row.insertCell(2).textContent = d.count;
      });

      // 구술시험 정보 추가
      const speakingSection = document.createElement("div");
      speakingSection.className = "section";
      speakingSection.innerHTML = `
        <h2>7. 구술시험 시간 관리</h2>
        <p>구술시험은 총 25분간 진행되며, 다음과 같은 문항으로 구성됩니다:</p>
        <ul>
          ${df_questions_speaking
            .map((q) => `<li>${q.평가영역}: ${q.배점}점</li>`)
            .join("")}
        </ul>
        <p>각 문항에 평균적으로 5분씩 할애하되, 난이도에 따라 시간을 조절하세요. 특히 다음 사항에 주의하세요:</p>
        <ul>
          <li>발음 문항에서는 정확성에 집중하되 너무 많은 시간을 소비하지 않도록 주의하세요.</li>
          <li>통합 문항은 여러 기능을 평가하므로, 시간 안에 모든 요소를 다루도록 노력하세요.</li>
          <li>말하기 문항에서는 내용의 구조화와 유창성 사이의 균형을 유지하세요.</li>
        </ul>
      `;
      document.querySelector(".container").appendChild(speakingSection);

      // 난이도별 시간 관리 팁 추가
      const difficultySection = document.createElement("div");
      difficultySection.className = "section";
      difficultySection.innerHTML = `
        <h2>8. 난이도별 시간 관리 팁</h2>
        <p>문항의 난이도에 따라 다음과 같은 전략을 사용하세요:</p>
        <ul>
          <li>쉬운 문항 (난이도 < 0): 빠르게 답하고 넘어가세요. 평균 시간의 2/3 정도를 목표로 하세요.</li>
          <li>보통 문항 (0 ≤ 난이도 < 0.5): 평균 시간을 기준으로 답하세요.</li>
          <li>어려운 문항 (난이도 ≥ 0.5): 추가 시간이 필요할 수 있습니다. 하지만 한 문항에 너무 많은 시간을 쓰지 않도록 주의하세요.</li>
        </ul>
        <p>전체 문항의 평균 난이도: ${
          Math.round(d3.mean(df_questions, (d) => d.난이도) * 100) / 100
        }</p>
      `;
      document.querySelector(".container").appendChild(difficultySection);

      // 난이도 분포 히스토그램 추가
      const difficultyHistogram = document.createElement("div");
      difficultyHistogram.id = "difficultyHistogram";
      difficultySection.appendChild(difficultyHistogram);

      const difficultyMargin = { top: 10, right: 30, bottom: 30, left: 40 },
        difficultyWidth = 460 - difficultyMargin.left - difficultyMargin.right,
        difficultyHeight = 400 - difficultyMargin.top - difficultyMargin.bottom;

      const difficultySvg = d3
        .select("#difficultyHistogram")
        .append("svg")
        .attr(
          "width",
          difficultyWidth + difficultyMargin.left + difficultyMargin.right
        )
        .attr(
          "height",
          difficultyHeight + difficultyMargin.top + difficultyMargin.bottom
        )
        .append("g")
        .attr(
          "transform",
          `translate(${difficultyMargin.left},${difficultyMargin.top})`
        );

      const difficultyX = d3
        .scaleLinear()
        .domain(d3.extent(df_questions, (d) => d.난이도))
        .range([0, difficultyWidth]);

      difficultySvg
        .append("g")
        .attr("transform", `translate(0,${difficultyHeight})`)
        .call(d3.axisBottom(difficultyX));

      const difficultyHistogram2 = d3
        .histogram()
        .value((d) => d.난이도)
        .domain(difficultyX.domain())
        .thresholds(difficultyX.ticks(20));

      const difficultyBins = difficultyHistogram2(df_questions);

      const difficultyY = d3
        .scaleLinear()
        .range([difficultyHeight, 0])
        .domain([0, d3.max(difficultyBins, (d) => d.length)]);

      difficultySvg.append("g").call(d3.axisLeft(difficultyY));

      difficultySvg
        .selectAll("rect")
        .data(difficultyBins)
        .join("rect")
        .attr("x", (d) => difficultyX(d.x0) + 1)
        .attr("width", (d) =>
          Math.max(0, difficultyX(d.x1) - difficultyX(d.x0) - 1)
        )
        .attr("y", (d) => difficultyY(d.length))
        .attr("height", (d) => difficultyHeight - difficultyY(d.length))
        .style("fill", "#69b3a2");

      difficultySvg
        .append("text")
        .attr("text-anchor", "end")
        .attr("x", difficultyWidth)
        .attr("y", difficultyHeight + difficultyMargin.top + 20)
        .text("난이도");

      difficultySvg
        .append("text")
        .attr("text-anchor", "end")
        .attr("transform", "rotate(-90)")
        .attr("y", -difficultyMargin.left + 20)
        .attr("x", -difficultyMargin.top)
        .text("문항 수");
    </script>
  </body>
</html>
