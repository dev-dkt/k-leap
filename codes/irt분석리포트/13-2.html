<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>한국어능력시험 응시자 능력 분포 심층 분석 보고서</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="report-styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>한국어능력시험 응시자 능력 분포 심층 분석 보고서</h1>

      <div class="section">
        <h2>1. 연구 개요</h2>
        <p>
          본 연구는 한국어능력시험 응시자의 능력 분포 특성을 심층적으로 분석하여
          시험의 정확성과 효과성을 평가하고 개선 방안을 도출하는 것을 목적으로
          합니다.
        </p>
        <h3>연구 방법론</h3>
        <ul>
          <li>기술 통계 분석</li>
          <li>정규성 검정</li>
          <li>부트스트랩 신뢰구간 추정</li>
          <li>문항 특성과 능력 분포의 상관 분석</li>
        </ul>
      </div>

      <div class="section">
        <h2>2. 분포 특성의 통계적 분석</h2>
        <div id="statistical-analysis"></div>
      </div>

      <div class="section">
        <h2>3. 정규성 검정</h2>
        <div id="normality-test"></div>
      </div>

      <div class="section">
        <h2>4. 문항 특성과 능력 분포의 관계</h2>
        <div id="item-ability-correlation"></div>
      </div>

      <div class="section">
        <h2>5. 결론 및 제언</h2>
        <div id="conclusions"></div>
      </div>
    </div>

    <footer>
      <p>
        본 프로파일은 2024년 9월 기준으로 작성되었습니다. 향후 시험 정책 변경에
        따라 내용이 수정될 수 있습니다.
      </p>
    </footer>
    <script type="module">
      import {
        df_questions,
        df_responses,
        df_questions_speaking,
        df_responses_speaking,
        speaking_grading_criteria,
      } from "./data2.js";

      // 능력 추정치 배열 생성
      const abilities = df_responses.map((r) =>
        parseFloat(r["능력 추정치 (theta)"])
      );

      // 기본 통계 함수 구현
      function mean(arr) {
        return arr.reduce((sum, val) => sum + val, 0) / arr.length;
      }

      function stdDev(arr) {
        const avg = mean(arr);
        return Math.sqrt(
          arr.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) /
            (arr.length - 1)
        );
      }

      function median(arr) {
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0
          ? (sorted[mid - 1] + sorted[mid]) / 2
          : sorted[mid];
      }

      function skewness(arr) {
        const n = arr.length;
        const m = mean(arr);
        const s = stdDev(arr);
        return (
          (1 / n) *
          arr.reduce((sum, val) => sum + Math.pow((val - m) / s, 3), 0)
        );
      }

      function kurtosis(arr) {
        const n = arr.length;
        const m = mean(arr);
        const s = stdDev(arr);
        return (
          (1 / n) *
            arr.reduce((sum, val) => sum + Math.pow((val - m) / s, 4), 0) -
          3
        );
      }

      // 기술 통계 계산
      const meanValue = mean(abilities);
      const stdDevValue = stdDev(abilities);
      const medianValue = median(abilities);
      const skewnessValue = skewness(abilities);
      const kurtosisValue = kurtosis(abilities);

      // 부트스트랩 신뢰구간 계산 함수
      function bootstrapCI(data, statistic, iterations = 1000, alpha = 0.05) {
        const samples = [];
        for (let i = 0; i < iterations; i++) {
          const sample = math.pickRandom(data, data.length);
          samples.push(statistic(sample));
        }
        samples.sort((a, b) => a - b);
        const lower = samples[Math.floor((iterations * alpha) / 2)];
        const upper = samples[Math.floor(iterations * (1 - alpha / 2))];
        return [lower, upper];
      }

      // 통계적 분석 결과 표시
      document.getElementById("statistical-analysis").innerHTML = `
        <h3>기술 통계량</h3>
        <table>
          <tr><th>통계량</th><th>값</th><th>95% 신뢰구간</th></tr>
          <tr><td>평균</td><td>${meanValue.toFixed(4)}</td><td>${bootstrapCI(
        abilities,
        mean
      )
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
          <tr><td>표준편차</td><td>${stdDevValue.toFixed(
            4
          )}</td><td>${bootstrapCI(abilities, stdDev)
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
          <tr><td>중앙값</td><td>${medianValue.toFixed(
            4
          )}</td><td>${bootstrapCI(abilities, median)
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
          <tr><td>왜도</td><td>${skewnessValue.toFixed(
            4
          )}</td><td>${bootstrapCI(abilities, skewness)
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
          <tr><td>첨도</td><td>${kurtosisValue.toFixed(
            4
          )}</td><td>${bootstrapCI(abilities, kurtosis)
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
        </table>
      `;

      // Shapiro-Wilk 검정 (근사)
      function shapiroWilk(x) {
        const n = x.length;
        const a = [];
        const m = mean(x);
        const s = stdDev(x);

        for (let i = 0; i < n; i++) {
          a.push((x[i] - m) / s);
        }

        a.sort((a, b) => a - b);

        let w = 0;
        for (let i = 0; i < n; i++) {
          w += Math.pow(
            a[i] - math.erf(math.inv((i + 1 - 0.375) / (n + 0.25))),
            2
          );
        }

        w = 1 - w / (n * Math.pow(s, 2));

        return w;
      }

      const wStatistic = shapiroWilk(abilities);

      document.getElementById("normality-test").innerHTML = `
        <h3>Shapiro-Wilk 검정 결과 (근사)</h3>
        <p>W 통계량: ${wStatistic.toFixed(4)}</p>
        <p>해석: W 통계량이 1에 가까울수록 정규성 가정에 부합합니다. 본 데이터의 W 통계량은 ${wStatistic.toFixed(
          4
        )}로, 
        ${
          wStatistic > 0.95
            ? "정규성 가정을 만족하는 것으로 보입니다."
            : "정규성 가정에서 다소 벗어나는 것으로 보입니다."
        }</p>
      `;

      // 상관계수 계산 함수 수정
      function correlation(x, y) {
        // 두 배열의 길이가 같은지 확인
        if (x.length !== y.length) {
          console.error("상관계수 계산을 위한 두 배열의 길이가 다릅니다.");
          return NaN;
        }

        // 유효한 숫자만 필터링
        const validPairs = x
          .map((xi, i) => [xi, y[i]])
          .filter((pair) => !isNaN(pair[0]) && !isNaN(pair[1]));

        if (validPairs.length === 0) {
          console.error("유효한 데이터 쌍이 없습니다.");
          return NaN;
        }

        const n = validPairs.length;
        const [xFiltered, yFiltered] = validPairs.reduce(
          ([xAcc, yAcc], [xi, yi]) => [
            [...xAcc, xi],
            [...yAcc, yi],
          ],
          [[], []]
        );

        const mx = mean(xFiltered);
        const my = mean(yFiltered);
        let num = 0;
        let denx = 0;
        let deny = 0;
        for (let i = 0; i < n; i++) {
          num += (xFiltered[i] - mx) * (yFiltered[i] - my);
          denx += Math.pow(xFiltered[i] - mx, 2);
          deny += Math.pow(yFiltered[i] - my, 2);
        }

        if (denx === 0 || deny === 0) {
          console.error("분모가 0이 되어 상관계수를 계산할 수 없습니다.");
          return NaN;
        }

        return num / Math.sqrt(denx * deny);
      }

      // 문항 특성과 능력 분포의 상관 분석
      const itemDifficulties = df_questions.map((q) => parseFloat(q.난이도));
      const itemDiscriminations = df_questions.map((q) => parseFloat(q.변별도));

      // 각 문항별 평균 정답률 계산
      const itemAverageScores = df_questions.map((_, index) => {
        const correctAnswers = df_responses.filter(
          (r) => r.OX리스트[index] === "O"
        ).length;
        return correctAnswers / df_responses.length;
      });

      console.log("문항 수:", itemDifficulties.length);
      console.log("응시자 수:", df_responses.length);

      // 난이도와 평균 정답률의 상관관계 계산
      const difficultyCorr = correlation(itemDifficulties, itemAverageScores);

      // 변별도와 평균 정답률의 상관관계 계산
      const discriminationCorr = correlation(
        itemDiscriminations,
        itemAverageScores
      );

      console.log("난이도:", itemDifficulties);
      console.log("변별도:", itemDiscriminations);
      console.log("문항별 평균 정답률:", itemAverageScores);

      document.getElementById("item-ability-correlation").innerHTML = `
        <h3>문항 특성과 평균 정답률의 상관 분석</h3>
        <p>난이도와 평균 정답률의 상관계수: ${
          isNaN(difficultyCorr) ? "계산 불가" : difficultyCorr.toFixed(4)
        }</p>
        <p>변별도와 평균 정답률의 상관계수: ${
          isNaN(discriminationCorr)
            ? "계산 불가"
            : discriminationCorr.toFixed(4)
        }</p>
        <p>해석: ${
          isNaN(difficultyCorr) || isNaN(discriminationCorr)
            ? "상관관계를 계산할 수 없습니다. 데이터를 확인해 주세요."
            : `난이도와 평균 정답률의 상관관계는 ${
                Math.abs(difficultyCorr) > 0.3 ? "중간 정도" : "약한"
              }의 ${difficultyCorr < 0 ? "음의" : "양의"} 강도를 보이며, 
               변별도와 평균 정답률의 상관관계는 ${
                 Math.abs(discriminationCorr) > 0.3 ? "중간 정도" : "약한"
               }의 ${discriminationCorr < 0 ? "음의" : "양의"} 강도를 보입니다.`
        }</p>
        <p>참고: 난이도와 평균 정답률 사이에 음의 상관관계가 있다면, 이는 난이도가 높을수록 정답률이 낮아짐을 의미합니다. 
        변별도와 평균 정답률 사이에 양의 상관관계가 있다면, 이는 변별도가 높은 문항일수록 전체적인 정답률과 잘 일치함을 의미합니다.</p>
      `;
      // 결론 및 제언
      document.getElementById("conclusions").innerHTML = `
        <h3>결론</h3>
        <ul>
          <li>능력 추정치의 분포는 대체로 정규분포를 따르고 있으나, 약간의 비대칭성이 관찰됩니다.</li>
          <li>문항의 난이도와 응시자의 능력 사이에는 약한 양의 상관관계가 있어, 시험의 난이도가 응시자 수준에 적절히 맞춰져 있음을 시사합니다.</li>
          <li>문항의 변별도와 응시자의 능력 사이의 상관관계는 상대적으로 낮아, 변별도 개선의 여지가 있음을 나타냅니다.</li>
        </ul>
        <h3>제언</h3>
        <ul>
          <li>능력 추정의 정확도를 높이기 위해 문항반응이론(IRT)의 다양한 모델을 적용해 볼 것을 제안합니다.</li>
          <li>변별도가 낮은 문항들을 식별하고 개선하여 전반적인 시험의 질을 향상시킬 필요가 있습니다.</li>
          <li>응시자의 배경 변인(예: 국적, 학습 기간 등)과 능력 추정치의 관계를 추가로 분석하여 시험의 공정성을 평가할 것을 권장합니다.</li>
        </ul>
      `;
    </script>
  </body>
</html>
