<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>한국어능력시험 응시자 능력 분포 심층 분석 보고서</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="report-styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>한국어능력시험 응시자 능력 분포 심층 분석 보고서</h1>

      <div class="section">
        <h2>1. 연구 개요</h2>
        <p>
          본 연구는 한국어능력시험 응시자의 능력 분포 특성을 심층적으로 분석하여
          시험의 정확성과 효과성을 평가하고 개선 방안을 도출하는 것을 목적으로
          합니다.
        </p>
        <h3>연구 방법론</h3>
        <ul>
          <li>기술 통계 분석</li>
          <li>정규성 검정</li>
          <li>부트스트랩 신뢰구간 추정</li>
          <li>문항 특성과 능력 분포의 상관 분석</li>
        </ul>
      </div>

      <div class="section">
        <h2>2. 분포 특성의 통계적 분석</h2>
        <div id="statistical-analysis"></div>
        <canvas id="ability-distribution-chart"></canvas>
      </div>

      <div class="section">
        <h2>3. 정규성 검정</h2>
        <div id="normality-test"></div>
        <canvas id="qq-plot"></canvas>
      </div>

      <div class="section">
        <h2>4. 문항 특성과 능력 분포의 관계</h2>
        <div id="item-ability-correlation"></div>
        <canvas id="difficulty-score-scatter"></canvas>
        <canvas id="discrimination-score-scatter"></canvas>
      </div>

      <div class="section">
        <h2>5. 결론 및 제언</h2>
        <div id="conclusions"></div>
      </div>
    </div>

    <footer>
      <p>
        본 프로파일은 2024년 9월 기준으로 작성되었습니다. 향후 시험 정책 변경에
        따라 내용이 수정될 수 있습니다.
      </p>
    </footer>
    <script type="module">
      import {
        df_questions as _df_questions,
        df_responses,
        df_questions_speaking as _df_questions_speaking,
        df_responses_speaking,
        speaking_grading_criteria,
      } from "./data2.js";

      const df_questions = _df_questions.map((q) => {
        q.난이도 = parseFloat(q.난이도);
        q.변별도 = parseFloat(q.변별도);
        return q;
      });
      const df_questions_speaking = _df_questions_speaking.map((q) => {
        q.난이도 = parseFloat(q.난이도);
        q.변별도 = parseFloat(q.변별도);
        return q;
      });

      // 능력 추정치 배열 생성
      const abilities = df_responses
        .map((r) => parseFloat(r["능력 추정치 (theta)"]))
        .filter((x) => !isNaN(x));

      // 기본 통계 함수 구현
      function mean(arr) {
        return arr.reduce((sum, val) => sum + val, 0) / arr.length;
      }

      function stdDev(arr) {
        const avg = mean(arr);
        return Math.sqrt(
          arr.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) /
            (arr.length - 1)
        );
      }

      function median(arr) {
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0
          ? (sorted[mid - 1] + sorted[mid]) / 2
          : sorted[mid];
      }

      function skewness(arr) {
        const n = arr.length;
        const m = mean(arr);
        const s = stdDev(arr);
        return (
          (1 / n) *
          arr.reduce((sum, val) => sum + Math.pow((val - m) / s, 3), 0)
        );
      }

      function kurtosis(arr) {
        const n = arr.length;
        const m = mean(arr);
        const s = stdDev(arr);
        return (
          (1 / n) *
            arr.reduce((sum, val) => sum + Math.pow((val - m) / s, 4), 0) -
          3
        );
      }

      // 기술 통계 계산
      const meanValue = mean(abilities);
      const stdDevValue = stdDev(abilities);
      const medianValue = median(abilities);
      const skewnessValue = skewness(abilities);
      const kurtosisValue = kurtosis(abilities);

      // 부트스트랩 신뢰구간 계산 함수
      function bootstrapCI(data, statistic, iterations = 1000, alpha = 0.05) {
        const samples = [];
        for (let i = 0; i < iterations; i++) {
          const sample = math.pickRandom(data, data.length);
          samples.push(statistic(sample));
        }
        samples.sort((a, b) => a - b);
        const lower = samples[Math.floor((iterations * alpha) / 2)];
        const upper = samples[Math.floor(iterations * (1 - alpha / 2))];
        return [lower, upper];
      }

      // 통계적 분석 결과 표시
      document.getElementById("statistical-analysis").innerHTML = `
        <h3>기술 통계량</h3>
        <table>
          <tr><th>통계량</th><th>값</th><th>95% 신뢰구간</th></tr>
          <tr><td>평균</td><td>${meanValue.toFixed(4)}</td><td>${bootstrapCI(
        abilities,
        mean
      )
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
          <tr><td>표준편차</td><td>${stdDevValue.toFixed(
            4
          )}</td><td>${bootstrapCI(abilities, stdDev)
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
          <tr><td>중앙값</td><td>${medianValue.toFixed(
            4
          )}</td><td>${bootstrapCI(abilities, median)
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
          <tr><td>왜도</td><td>${skewnessValue.toFixed(
            4
          )}</td><td>${bootstrapCI(abilities, skewness)
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
          <tr><td>첨도</td><td>${kurtosisValue.toFixed(
            4
          )}</td><td>${bootstrapCI(abilities, kurtosis)
        .map((v) => v.toFixed(4))
        .join(" - ")}</td></tr>
        </table>
      `;

      // 능력 분포 히스토그램 생성
      const ctx = document
        .getElementById("ability-distribution-chart")
        .getContext("2d");
      const histogramData = d3
        .histogram()
        .domain(d3.extent(abilities))
        .thresholds(20)(abilities);

      new Chart(ctx, {
        type: "bar",
        data: {
          labels: histogramData.map((d) => d.x0.toFixed(2)), // x축 라벨을 소수점 2자리로 제한
          datasets: [
            {
              label: "빈도",
              data: histogramData.map((d) => d.length),
              backgroundColor: "rgba(75, 192, 192, 0.6)",
              borderColor: "rgba(75, 192, 192, 1)",
              borderWidth: 1,
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            x: {
              title: {
                display: true,
                text: "능력 추정치 (θ)",
              },
              ticks: {
                callback: function (value) {
                  return parseFloat(value).toFixed(2); // 틱 라벨도 소수점 2자리로 제한
                },
              },
            },
            y: {
              title: {
                display: true,
                text: "빈도",
              },
              beginAtZero: true,
            },
          },
          plugins: {
            title: {
              display: true,
              text: "능력 추정치 분포",
            },
            tooltip: {
              callbacks: {
                title: function (tooltipItems) {
                  return `능력 추정치: ${parseFloat(
                    tooltipItems[0].label
                  ).toFixed(2)}`; // 툴팁의 제목도 소수점 2자리로 제한
                },
              },
            },
          },
        },
      });

      // Shapiro-Wilk 검정 (근사)
      function shapiroWilk(x) {
        const n = x.length;
        const a = [];
        const m = mean(x);
        const s = stdDev(x);

        for (let i = 0; i < n; i++) {
          a.push((x[i] - m) / s);
        }

        a.sort((a, b) => a - b);

        let w = 0;
        for (let i = 0; i < n; i++) {
          w += Math.pow(
            a[i] - math.erf(math.inv((i + 1 - 0.375) / (n + 0.25))),
            2
          );
        }

        w = 1 - w / (n * Math.pow(s, 2));

        return w;
      }

      const wStatistic = shapiroWilk(abilities);

      document.getElementById("normality-test").innerHTML = `
        <h3>Shapiro-Wilk 검정 결과 (근사)</h3>
        <p>W 통계량: ${wStatistic.toFixed(4)}</p>
        <p>해석: W 통계량이 1에 가까울수록 정규성 가정에 부합합니다. 본 데이터의 W 통계량은 ${wStatistic.toFixed(
          4
        )}로, 
        ${
          wStatistic > 0.95
            ? "정규성 가정을 만족하는 것으로 보입니다."
            : "정규성 가정에서 다소 벗어나는 것으로 보입니다."
        }</p>
      `;

      // 표준정규분포의 역함수 구현
      function inverseNormal(p) {
        const a1 = -39.6968302866538,
          a2 = 220.946098424521,
          a3 = -275.928510446969;
        const a4 = 138.357751867269,
          a5 = -30.6647980661472,
          a6 = 2.50662827745924;
        const b1 = -54.4760987982241,
          b2 = 161.585836858041,
          b3 = -155.698979859887;
        const b4 = 66.8013118877197,
          b5 = -13.2806815528857,
          c1 = -7.78489400243029e-3;
        const c2 = -0.322396458041136,
          c3 = -2.40075827716184,
          c4 = -2.54973253934373;
        const c5 = 4.37466414146497,
          c6 = 2.93816398269878,
          d1 = 7.78469570904146e-3;
        const d2 = 0.32246712907004,
          d3 = 2.445134137143,
          d4 = 3.75440866190742;
        const p_low = 0.02425,
          p_high = 1 - p_low;
        let q, r;
        if (p < p_low) {
          q = Math.sqrt(-2 * Math.log(p));
          return (
            (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
            ((((d1 * q + d2) * q + d3) * q + d4) * q + 1)
          );
        } else if (p <= p_high) {
          q = p - 0.5;
          r = q * q;
          return (
            ((((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6) * q) /
            (((((b1 * r + b2) * r + b3) * r + b4) * r + b5) * r + 1)
          );
        } else {
          q = Math.sqrt(-2 * Math.log(1 - p));
          return (
            -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) /
            ((((d1 * q + d2) * q + d3) * q + d4) * q + 1)
          );
        }
      }

      // Q-Q 플롯 생성
      const qqCtx = document.getElementById("qq-plot").getContext("2d");
      const sortedAbilities = [...abilities].sort((a, b) => a - b);
      const theoreticalQuantiles = sortedAbilities.map((_, i) =>
        inverseNormal((i + 1 - 0.375) / (sortedAbilities.length + 0.25))
      );

      new Chart(qqCtx, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "Q-Q 플롯",
              data: sortedAbilities.map((ability, i) => ({
                x: theoreticalQuantiles[i],
                y: ability,
              })),
              backgroundColor: "rgba(75, 192, 192, 0.6)",
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            x: {
              title: {
                display: true,
                text: "이론적 분위수",
              },
            },
            y: {
              title: {
                display: true,
                text: "관측된 분위수",
              },
            },
          },
          plugins: {
            title: {
              display: true,
              text: "정규 Q-Q 플롯",
            },
          },
        },
      });

      // 상관계수 계산 함수
      function correlation(x, y) {
        const n = x.length;
        const mx = mean(x);
        const my = mean(y);
        let num = 0;
        let denx = 0;
        let deny = 0;
        for (let i = 0; i < n; i++) {
          num += (x[i] - mx) * (y[i] - my);
          denx += Math.pow(x[i] - mx, 2);
          deny += Math.pow(y[i] - my, 2);
        }
        return num / Math.sqrt(denx * deny);
      }

      // 문항 특성과 능력 분포의 상관 분석
      const itemDifficulties = df_questions.map((q) => parseFloat(q.난이도));
      const itemDiscriminations = df_questions.map((q) => parseFloat(q.변별도));

      // 각 문항별 평균 정답률 계산
      const itemAverageScores = df_questions.map((_, index) => {
        const correctAnswers = df_responses.filter(
          (r) => r.OX리스트[index] === "O"
        ).length;
        return correctAnswers / df_responses.length;
      });

      // 난이도와 평균 정답률의 상관관계 계산
      const difficultyCorr = correlation(itemDifficulties, itemAverageScores);

      // 변별도와 평균 정답률의 상관관계 계산
      const discriminationCorr = correlation(
        itemDiscriminations,
        itemAverageScores
      );

      document.getElementById("item-ability-correlation").innerHTML = `
        <h3>문항 특성과 평균 정답률의 상관 분석</h3>
        <p>난이도와 평균 정답률의 상관계수: ${difficultyCorr.toFixed(4)}</p>
        <p>변별도와 평균 정답률의 상관계수: ${discriminationCorr.toFixed(4)}</p>
        <p>해석: 난이도와 평균 정답률의 상관관계는 ${
          Math.abs(difficultyCorr) > 0.3 ? "중간 정도" : "약한"
        }의 ${difficultyCorr < 0 ? "음의" : "양의"} 강도를 보이며, 
               변별도와 평균 정답률의 상관관계는 ${
                 Math.abs(discriminationCorr) > 0.3 ? "중간 정도" : "약한"
               }의 ${
        discriminationCorr < 0 ? "음의" : "양의"
      } 강도를 보입니다.</p>
        <p>참고: 난이도와 평균 정답률 사이에 음의 상관관계가 있다면, 이는 난이도가 높을수록 정답률이 낮아짐을 의미합니다. 
        변별도와 평균 정답률 사이에 양의 상관관계가 있다면, 이는 변별도가 높은 문항일수록 전체적인 정답률과 잘 일치함을 의미합니다.</p>
      `;

      // 난이도와 평균 정답률 산점도
      const difficultyCtx = document
        .getElementById("difficulty-score-scatter")
        .getContext("2d");
      new Chart(difficultyCtx, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "난이도 vs 평균 정답률",
              data: itemDifficulties.map((difficulty, i) => ({
                x: difficulty,
                y: itemAverageScores[i],
              })),
              backgroundColor: "rgba(75, 192, 192, 0.6)",
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            x: {
              title: {
                display: true,
                text: "문항 난이도",
              },
            },
            y: {
              title: {
                display: true,
                text: "평균 정답률",
              },
            },
          },
          plugins: {
            title: {
              display: true,
              text: "문항 난이도와 평균 정답률의 관계",
            },
          },
        },
      });

      // 변별도와 평균 정답률 산점도
      const discriminationCtx = document
        .getElementById("discrimination-score-scatter")
        .getContext("2d");
      new Chart(discriminationCtx, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "변별도 vs 평균 정답률",
              data: itemDiscriminations.map((discrimination, i) => ({
                x: discrimination,
                y: itemAverageScores[i],
              })),
              backgroundColor: "rgba(255, 99, 132, 0.6)",
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            x: {
              title: {
                display: true,
                text: "문항 변별도",
              },
            },
            y: {
              title: {
                display: true,
                text: "평균 정답률",
              },
            },
          },
          plugins: {
            title: {
              display: true,
              text: "문항 변별도와 평균 정답률의 관계",
            },
          },
        },
      });

      // 결론 및 제언
      document.getElementById("conclusions").innerHTML = `
        <h3>결론</h3>
        <ul>
          <li>능력 추정치의 분포는 대체로 정규분포를 따르고 있으나, 약간의 비대칭성이 관찰됩니다 (왜도: ${skewnessValue.toFixed(
            4
          )}).</li>
          <li>문항의 난이도와 평균 정답률 사이에는 ${
            Math.abs(difficultyCorr) > 0.3 ? "중간 정도" : "약한"
          } ${
        difficultyCorr < 0 ? "음의" : "양의"
      } 상관관계 (${difficultyCorr.toFixed(4)})가 있어, 
          ${
            difficultyCorr < 0
              ? "난이도가 높을수록 정답률이 낮아지는 경향이 있음을"
              : "난이도와 정답률 사이에 예상과 다른 관계가 있음을"
          } 시사합니다.</li>
          <li>문항의 변별도와 평균 정답률 사이의 상관관계는 ${
            Math.abs(discriminationCorr) > 0.3 ? "중간 정도" : "약한"
          } 수준 (${discriminationCorr.toFixed(4)})으로, 
          ${
            discriminationCorr > 0
              ? "변별도가 높은 문항일수록 전체적인 정답률과 일치하는 경향이 있음을"
              : "변별도와 정답률 사이에 예상과 다른 관계가 있음을"
          } 나타냅니다.</li>
        </ul>
        <h3>제언</h3>
        <ul>
          <li>능력 추정의 정확도를 높이기 위해 문항반응이론(IRT)의 다양한 모델을 적용해 볼 것을 제안합니다.</li>
          <li>변별도가 낮은 문항들을 식별하고 개선하여 전반적인 시험의 질을 향상시킬 필요가 있습니다.</li>
          <li>난이도와 정답률의 관계가 ${
            difficultyCorr < 0 ? "예상대로" : "예상과 다르게"
          } 나타났으므로, 개별 문항의 특성을 더 자세히 분석할 필요가 있습니다.</li>
          <li>응시자의 배경 변인(예: 국적, 학습 기간 등)과 능력 추정치의 관계를 추가로 분석하여 시험의 공정성을 평가할 것을 권장합니다.</li>
          <li>말하기 평가 결과와 필기 시험 결과의 상관관계를 분석하여 전반적인 언어 능력 평가의 타당성을 검증할 것을 제안합니다.</li>
        </ul>
      `;

      // 말하기 평가 분석 추가
      const speakingScores = df_responses_speaking.map((r) =>
        parseFloat(r.점수)
      );
      const speakingMean = mean(speakingScores);
      const speakingStdDev = stdDev(speakingScores);

      document.getElementById("conclusions").innerHTML += `
        <h3>말하기 평가 분석</h3>
        <p>말하기 평가 평균 점수: ${speakingMean.toFixed(2)}</p>
        <p>말하기 평가 표준편차: ${speakingStdDev.toFixed(2)}</p>
        <p>말하기 능력과 전체 능력 추정치의 상관계수: ${correlation(
          speakingScores,
          abilities
        ).toFixed(4)}</p>
        <p>해석: 말하기 능력과 전체 능력 추정치 사이에 ${
          Math.abs(correlation(speakingScores, abilities)) > 0.3
            ? "중간 정도"
            : "약한"
        } 상관관계가 있습니다. 
        이는 말하기 평가가 전체 언어 능력을 어느 정도 반영하고 있음을 시사하지만, 개선의 여지가 있을 수 있습니다.</p>
      `;
    </script>
  </body>
</html>
