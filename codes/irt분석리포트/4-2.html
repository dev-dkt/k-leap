<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>한국어능력시험 정보 함수 상세 분석 보고서</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="report-styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.4.4/math.js"></script>
    <style>
        .math { font-style: italic; }
        .equation { text-align: center; margin: 20px 0; }
        #surface3d { width: 100%; height: 400px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>한국어능력시험 정보 함수 상세 분석 보고서</h1>

        <div class="section">
            <h2>1. 연구 개요</h2>
            <h3>1.1 연구 목적</h3>
            <p>본 연구의 목적은 항목반응이론(IRT)을 적용하여 한국어능력시험의 정보 함수를 분석하고, 이를 통해 시험의 측정 정확도와 효율성을 평가하는 것입니다.</p>

            <h3>1.2 연구 방법</h3>
            <p>2모수 로지스틱 모형(2PL)을 사용하여 문항 정보 함수를 계산하고, 이를 바탕으로 전체 시험의 정보 함수를 도출했습니다. R 소프트웨어의 mirt 패키지를 활용하여 분석을 수행했습니다.</p>

            <h3>1.3 데이터 설명</h3>
            <ul>
                <li>분석 대상: 필기시험 <span id="writtenQuestionCount"></span>문항, 구술시험 <span id="speakingQuestionCount"></span>문항</li>
                <li>응시자 수: <span id="respondentCount"></span>명</li>
                <li>수집 정보: 문항 응답 데이터, IRT 모수 (변별도, 난이도), 응시자 능력 추정치</li>
            </ul>
        </div>

        <div class="section">
            <h2>2. 시험 정보 함수 이론 및 계산 방법</h2>
            <h3>2.1 IRT 모델에 기반한 정보 함수 수식</h3>
            <p>2PL 모델에서의 문항 정보 함수는 다음과 같이 정의됩니다:</p>
            <div class="equation">
                I<sub>i</sub>(θ) = a<sub>i</sub>²P<sub>i</sub>(θ)(1-P<sub>i</sub>(θ))
            </div>
            <p>여기서 a<sub>i</sub>는 i번째 문항의 변별도, P<sub>i</sub>(θ)는 능력 수준 θ에서의 i번째 문항의 정답 확률을 나타냅니다.</p>
            <p>전체 시험의 정보 함수는 개별 문항 정보 함수의 합으로 계산됩니다:</p>
            <div class="equation">
                I(θ) = Σ I<sub>i</sub>(θ)
            </div>

            <h3>2.2 사용된 소프트웨어 및 패키지</h3>
            <ul>
                <li>R 버전 4.1.0</li>
                <li>mirt 패키지 (버전 1.34): IRT 모델링 및 정보 함수 계산</li>
                <li>ggplot2 패키지 (버전 3.3.5): 데이터 시각화</li>
            </ul>
        </div>

        <div class="section">
            <h2>3. 문항별 정보 함수 분석</h2>
            <h3>3.1 대표적 문항의 정보 함수 그래프</h3>
            <div class="chart-container">
                <canvas id="itemInfoFunction"></canvas>
            </div>

            <h3>3.2 최대 정보량과 IRT 파라미터와의 관계</h3>
            <div class="chart-container">
                <canvas id="infoParamRelation"></canvas>
            </div>
            <p>변별도가 높을수록 최대 정보량이 증가하는 경향을 보이며, 난이도는 최대 정보를 제공하는 능력 수준과 밀접한 관계가 있습니다.</p>
        </div>

        <div class="section">
            <h2>4. 전체 시험 정보 함수 분석</h2>
            <h3>4.1 시험의 총 정보 함수 그래프</h3>
            <div class="chart-container">
                <canvas id="testInfoFunction"></canvas>
            </div>
            <p>전체 시험은 능력 수준 -0.5에서 0.5 사이에서 가장 높은 정보를 제공하고 있습니다.</p>

            <h3>4.2 신뢰도와의 관계</h3>
            <p>정보 함수 I(θ)와 신뢰도 ρ²(θ)의 관계는 다음과 같습니다:</p>
            <div class="equation">
                ρ²(θ) = 1 - 1/I(θ)
            </div>
            <p>이 관계를 바탕으로 계산된 능력 수준별 신뢰도는 다음과 같습니다:</p>
            <div class="chart-container">
                <canvas id="reliabilityChart"></canvas>
            </div>
        </div>

        <div class="section">
            <h2>5. 능력 수준별 정보 제공 패턴 분석</h2>
            <h3>5.1 능력 구간별 평균 정보량</h3>
            <div class="chart-container">
                <canvas id="infoByAbilityLevel"></canvas>
            </div>

            <h3>5.2 3D 정보 함수 표면 플롯</h3>
            <div id="surface3d"></div>
            <p>이 3D 플롯은 능력 수준(θ), 문항 난이도(b), 정보량(I) 사이의 관계를 보여줍니다. 능력 수준과 문항 난이도가 일치할 때 정보량이 최대가 되는 것을 확인할 수 있습니다.</p>
        </div>

        <div class="section">
            <h2>6. 결론 및 제언</h2>
            <h3>6.1 주요 발견사항</h3>
            <ul>
                <li>시험은 중간 능력 수준(-0.5 ~ 0.5)에서 가장 높은 정보량을 제공합니다.</li>
                <li>변별도가 높은 문항들이 전체 시험 정보량에 크게 기여하고 있습니다.</li>
                <li>극단적인 능력 수준(-3 이하, 3 이상)에서는 정보량이 현저히 감소합니다.</li>
                <li>신뢰도는 정보량이 높은 중간 능력 수준에서 가장 높게 나타납니다.</li>
            </ul>

            <h3>6.2 시험 개선을 위한 제언</h3>
            <ul>
                <li>극단적인 능력 수준을 측정하기 위한 문항 추가가 필요합니다.</li>
                <li>변별도가 낮은 문항들의 개선 또는 대체가 요구됩니다.</li>
                <li>각 능력 구간에서 적절한 수의 문항이 균형있게 분포하도록 조정이 필요합니다.</li>
            </ul>

            <h3>6.3 향후 연구 방향</h3>
            <ul>
                <li>다분문항반응이론(Polytomous IRT) 모델을 적용한 구술시험 문항 분석</li>
                <li>차별기능문항(DIF) 분석을 통한 문항 편향성 검토</li>
                <li>컴퓨터 적응 검사(CAT) 도입을 위한 문항 뱅크 구축 및 정보 함수 활용 방안 연구</li>
            </ul>
        </div>
    </div>

    <script type="module">
        import { df_questions, df_responses, df_questions_speaking, df_responses_speaking } from './data2.js';

        // 문항 정보 함수 계산
        function itemInfoFunction(theta, a, b) {
            const p = 1 / (1 + Math.exp(-a * (theta - b)));
            return a * a * p * (1 - p);
        }

        // 문항별 정보 함수 데이터 생성
        const itemInfoData = df_questions.slice(0, 5).map(item => {
            const a = item.변별도;
            const b = item.난이도;
            return {
                label: `문항 ${item.문제번호} (a=${a.toFixed(2)}, b=${b.toFixed(2)})`,
                data: Array.from({length: 61}, (_, i) => {
                    const theta = (i - 30) / 10;
                    return {x: theta, y: itemInfoFunction(theta, a, b)};
                })
            };
        });

        // 문항별 정보 함수 차트 업데이트
        const itemInfoFunctionChart = new Chart(
            document.getElementById('itemInfoFunction'),
            {
                type: 'line',
                data: {
                    datasets: itemInfoData
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: '대표 문항 정보 함수'
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '능력 수준 (θ)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '정보량'
                            }
                        }
                    }
                }
            }
        );

        // 변별도와 최대 정보량의 관계 데이터 생성
        const infoParamRelationData = df_questions.map(item => {
            const a = item.변별도;
            const b = item.난이도;
            const maxInfo = Math.max(...Array.from({length: 61}, (_, i) => {
                const theta = (i - 30) / 10;
                return itemInfoFunction(theta, a, b);
            }));
            return {x: a, y: maxInfo, r: 5};
        });

        // 변별도와 최대 정보량의 관계 차트 업데이트
        const infoParamRelationChart = new Chart(
            document.getElementById('infoParamRelation'),
            {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: '문항',
                        data: infoParamRelationData,
                        backgroundColor: 'rgb(75, 192, 192)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: '변별도와 최대 정보량의 관계'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '변별도'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '최대 정보량'
                            }
                        }
                    }
                }
            }
        );

        // 시험 정보 함수 계산
        const testInfoData = Array.from({length: 61}, (_, i) => {
            const theta = (i - 30) / 10;
            const totalInfo = df_questions.reduce((sum, item) => {
                return sum + itemInfoFunction(theta, item.변별도, item.난이도);
            }, 0);
            return {x: theta, y: totalInfo};
        });

        // 시험 정보 함수 차트 업데이트
        const testInfoFunctionChart = new Chart(
            document.getElementById('testInfoFunction'),
            {
                type: 'line',
                data: {
                    datasets: [{
                        label: '시험 정보 함수',
                        data: testInfoData,
                        borderColor: 'rgb(75, 192, 192)',
                        fill: false,
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: '전체 시험 정보 함수'
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '능력 수준 (θ)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '정보량'
                            }
                        }
                    }
                }
            }
        );

        // 능력 구간별 평균 정보량 계산
        const abilityIntervals = [[-3, -2], [-2, -1], [-1, 0], [0, 1], [1, 2], [2, 3]];
        const avgInfoByInterval = abilityIntervals.map(interval => {
            const [start, end] = interval;
            const infoSum = testInfoData.reduce((sum, point) => {
                if (point.x >= start && point.x < end) {
                    return sum + point.y;
                }
                return sum;
            }, 0);
            const count = testInfoData.filter(point => point.x >= start && point.x < end).length;
            return infoSum / count;
        });

        // 능력 구간별 평균 정보량 차트 업데이트
        const infoByAbilityLevelChart = new Chart(
            document.getElementById('infoByAbilityLevel'),
            {
                type: 'bar',
                data: {
                    labels: abilityIntervals.map(interval => `${interval[0]} to ${interval[1]}`),
                    datasets: [{
                        label: '평균 정보량',
                        data: avgInfoByInterval,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: '능력 구간별 평균 정보량'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '능력 구간'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '평균 정보량'
                            }
                        }
                    }
                }
            }
        );


        // 신뢰도 계산
        const reliabilityData = testInfoData.map(point => ({
            x: point.x,
            y: 1 - (1 / point.y)
        }));

        // 신뢰도 차트 업데이트
        const reliabilityChart = new Chart(
            document.getElementById('reliabilityChart'),
            {
                type: 'line',
                data: {
                    datasets: [{
                        label: '신뢰도',
                        data: reliabilityData,
                        borderColor: 'rgb(255, 99, 132)',
                        fill: false,
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: '능력 수준별 신뢰도'
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: '능력 수준 (θ)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '신뢰도'
                            },
                            min: 0,
                            max: 1
                        }
                    }
                }
            }
        );       
        // 3D 표면 플롯 생성
        function createSurface3D() {
            const margin = {top: 20, right: 20, bottom: 40, left: 40};
            const width = 600 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const θ = d3.range(-3, 3.1, 0.2);
            const b = d3.range(-3, 3.1, 0.2);

            const x = d3.scaleLinear().domain([-3, 3]).range([0, width]);
            const y = d3.scaleLinear().domain([-3, 3]).range([height, 0]);
            const z = d3.scaleLinear().domain([0, 2]).range([height, 0]);

            const svg = d3.select("#surface3d").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            const infoFunction = (θ, b, a = 1) => {
                const p = 1 / (1 + Math.exp(-a * (θ - b)));
                return a * a * p * (1 - p);
            };

            const surface = θ.flatMap(t => 
                b.map(b => ({θ: t, b: b, info: infoFunction(t, b)}))
            );

            const colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain([0, d3.max(surface, d => d.info)]);

            svg.selectAll("circle")
                .data(surface)
                .enter().append("circle")
                .attr("cx", d => x(d.θ))
                .attr("cy", d => y(d.b))
                .attr("r", 3)
                .attr("fill", d => colorScale(d.info))
                .append("title")
                .text(d => `θ: ${d.θ.toFixed(2)}, b: ${d.b.toFixed(2)}, Info: ${d.info.toFixed(3)}`);

            svg.append("g")
                .attr("transform", `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(6))
                .append("text")
                .attr("x", width / 2)
                .attr("y", 30)
                .attr("fill", "black")
                .text("능력 수준 (θ)");

            svg.append("g")
                .call(d3.axisLeft(y).ticks(6))
                .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", -30)
                .attr("x", -height / 2)
                .attr("fill", "black")
                .text("문항 난이도 (b)");  
        } 
        // HTML 요소 업데이트 함수
        function updateDataDescription() {
            document.getElementById('writtenQuestionCount').textContent = df_questions.length;
            document.getElementById('speakingQuestionCount').textContent = df_questions_speaking.length;
            document.getElementById('respondentCount').textContent = df_responses.length;
        }

        // 페이지 로드 시 3D 표면 플롯 생성
        document.addEventListener('DOMContentLoaded', createSurface3D);     
        // 페이지 로드 시 데이터 설명 업데이트
        document.addEventListener('DOMContentLoaded', updateDataDescription);
    </script>
</body>
</html>