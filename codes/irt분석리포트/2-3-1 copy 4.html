<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>한국어능력시험 개인 능력 프로파일</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="report-styles.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
  </head>
  <body>
    <div class="container">
      <h1>한국어능력시험 개인 능력 프로파일</h1>

      <!-- 종합 섹션 -->
      <div class="section">
        <h2>1. 종합</h2>
        <!-- 종합 요약 -->
        <h3>1.1 개인 종합 능력 요약</h3>
        <table id="summaryTable">
          <thead>
            <tr>
              <th>이름</th>
              <th>필기 점수</th>
              <th>필기 능력 추정치 (θ)</th>
              <th>구술 점수</th>
              <th>구술 능력 추정치 (θ)</th>
              <th>종합 능력 추정치 (θ)</th>
              <th>백분위 순위 (%)</th>
            </tr>
          </thead>
          <tbody>
            <!-- 수험생 데이터가 여기에 추가됩니다 -->
          </tbody>
        </table>

        <!-- 능력 분포 차트 -->
        <h3>1.2 전체 수험생 능력 분포</h3>
        <div class="chart-container">
          <canvas id="abilityDistributionChart"></canvas>
        </div>
        <p>
          위 그래프는 전체 수험생의 종합 능력 추정치 분포를 나타냅니다. 당신의
          위치는 빨간색 점으로 표시되어 있습니다.
        </p>
      </div>

      <!-- 필기 섹션 -->
      <div class="section">
        <h2>2. 필기</h2>
        <!-- 문항별 정답 및 난이도 -->
        <h3>2.1 문항별 정답 및 난이도 (필기)</h3>
        <table id="questionDetailTableWriting">
          <thead>
            <tr>
              <th>문항 번호</th>
              <th>문항 코드</th>
              <th>정답 여부</th>
              <th>난이도</th>
              <th>변별도</th>
              <th>평가 영역</th>
              <th>평가 항목</th>
            </tr>
          </thead>
          <tbody>
            <!-- 필기 문항 데이터가 여기에 추가됩니다 -->
          </tbody>
        </table>

        <!-- 문항 난이도와 정답 현황 차트 -->
        <h3>2.2 문항 난이도와 정답 현황 (필기)</h3>
        <div class="chart-container">
          <canvas id="difficultyChartWriting"></canvas>
        </div>
        <p>
          아래 그래프는 필기 문항의 난이도와 수험생의 정답 여부를 나타냅니다.
        </p>

        <!-- 평가 영역별 성취도 -->
        <h3>2.3 평가 영역별 성취도 (필기)</h3>
        <table id="areaPerformanceTableWriting">
          <thead>
            <tr>
              <th>평가 영역</th>
              <th>총 문항 수</th>
              <th>맞은 문항 수</th>
              <th>정답률 (%)</th>
            </tr>
          </thead>
          <tbody>
            <!-- 필기 영역별 성취도 데이터가 여기에 추가됩니다 -->
          </tbody>
        </table>

        <!-- 평가 영역별 성취도 차트 -->
        <h3>2.4 평가 영역별 성취도 차트 (필기)</h3>
        <div class="chart-container">
          <canvas id="areaPerformanceChartWriting"></canvas>
        </div>

        <!-- 영역별 능력 프로파일 차트 추가 -->
        <h3>2.5 영역별 능력 프로파일 차트 (필기)</h3>
        <div class="chart-container">
          <canvas id="abilityProfileChartWriting"></canvas>
        </div>
      </div>

      <!-- 구술 섹션 -->
      <div class="section">
        <h2>3. 구술</h2>
        <!-- 문항별 정답 및 난이도 -->
        <h3>3.1 문항별 정답 및 난이도 (구술)</h3>
        <table id="questionDetailTableSpeaking">
          <thead>
            <tr>
              <th>문항 번호</th>
              <th>문항 코드</th>
              <th>정답 여부</th>
              <th>난이도</th>
              <th>변별도</th>
              <th>평가 영역</th>
              <th>평가 항목</th>
            </tr>
          </thead>
          <tbody>
            <!-- 구술 문항 데이터가 여기에 추가됩니다 -->
          </tbody>
        </table>

        <!-- 문항 난이도와 정답 현황 차트 -->
        <h3>3.2 문항 난이도와 정답 현황 (구술)</h3>
        <div class="chart-container">
          <canvas id="difficultyChartSpeaking"></canvas>
        </div>
        <p>
          아래 그래프는 구술 문항의 난이도와 수험생의 정답 여부를 나타냅니다.
        </p>

        <!-- 구술 시험 세부 평가 -->
        <h3>3.3 구술 시험 세부 평가</h3>
        <table id="speakingDetailTable">
          <thead>
            <tr>
              <th>문제 번호</th>
              <th>평가 목표</th>
              <th>수험생 점수</th>
              <th>평가 기준</th>
              <th>평가 기준 설명</th>
            </tr>
          </thead>
          <tbody>
            <!-- 구술 시험 세부 평가 데이터가 여기에 추가됩니다 -->
          </tbody>
        </table>

        <!-- 구술 시험 점수 분포 차트 -->
        <h3>3.4 구술 시험 점수 분포</h3>
        <div class="chart-container">
          <canvas id="speakingScoreDistributionChart"></canvas>
        </div>
        <p>
          위 그래프는 구술 시험에서의 전체 수험생 점수 분포를 나타냅니다. 당신의
          위치는 빨간색 막대로 표시되어 있습니다.
        </p>

        <!-- 영역별 능력 프로파일 차트 추가 -->
        <h3>3.5 영역별 능력 프로파일 차트 (구술)</h3>
        <div class="chart-container">
          <canvas id="abilityProfileChartSpeaking"></canvas>
        </div>
      </div>

      <!-- 전체 정리 섹션 -->
      <div class="section">
        <h2>4. 전체 정리</h2>
        <!-- 능력 추정치 비교 차트 -->
        <h3>4.1 능력 추정치 비교 (국적별)</h3>
        <div class="chart-container">
          <canvas id="nationalityComparisonChart"></canvas>
        </div>
        <p>
          위 그래프는 국적별 수험생의 종합 능력 추정치를 비교한 것입니다. 당신의
          위치는 빨간색 막대로 표시되어 있습니다.
        </p>

        <!-- 추천 학습 방향 및 개선점 -->
        <h3>4.2 추천 학습 방향 및 개선점</h3>
        <p id="recommendation">
          <!-- 추천 내용이 여기에 추가됩니다 -->
        </p>
      </div>
    </div>

    <footer>
      <p>
        본 프로파일은 2024년 9월 기준으로 작성되었습니다. 향후 시험 정책 변경에
        따라 내용이 수정될 수 있습니다.
      </p>
    </footer>
    <script type="module">
      import {
        df_questions,
        df_responses,
        df_questions_speaking,
        df_responses_speaking,
        speaking_grading_criteria,
      } from "./data2.js";

      // 수험생 선택 (무작위로 한 명 선택)
      const examinee =
        df_responses[Math.floor(Math.random() * df_responses.length)];

      // 해당 수험생의 구술 시험 데이터 찾기
      const speakingData = df_responses_speaking.find(
        (d) => d.외국인등록번호 === examinee.외국인등록번호
      );

      // 종합 능력 추정치 계산 (필기와 구술 평균)
      let overallTheta = parseFloat(examinee["능력 추정치 (theta)"]);
      if (speakingData) {
        overallTheta =
          (overallTheta + parseFloat(speakingData["능력 추정치 (theta)"])) / 2;
      }

      // 전체 수험생의 종합 능력 추정치 계산
      const allExaminees = df_responses.map((e) => {
        const speaking = df_responses_speaking.find(
          (d) => d.외국인등록번호 === e.외국인등록번호
        );
        let overall = parseFloat(e["능력 추정치 (theta)"]);
        if (speaking) {
          overall = (overall + parseFloat(speaking["능력 추정치 (theta)"])) / 2;
        }
        return {
          ...e,
          speakingData: speaking,
          overallTheta: overall,
        };
      });

      // 백분위 순위 계산
      const sortedAbilities = allExaminees
        .map((e) => e.overallTheta)
        .sort((a, b) => a - b);
      const rank = sortedAbilities.filter(
        (theta) => theta <= overallTheta
      ).length;
      const percentile = ((rank - 1) / (sortedAbilities.length - 1)) * 100;

      // 종합 섹션 - 개인 종합 능력 요약
      const summaryTableBody = document.querySelector("#summaryTable tbody");
      const summaryRow = document.createElement("tr");
      summaryRow.innerHTML = `
        <td>${examinee.이름}</td>
        <td>${examinee.점수}</td>
        <td>${parseFloat(examinee["능력 추정치 (theta)"]).toFixed(2)}</td>
        <td>${speakingData ? speakingData.점수 : "-"}</td>
        <td>${
          speakingData
            ? parseFloat(speakingData["능력 추정치 (theta)"]).toFixed(2)
            : "-"
        }</td>
        <td>${overallTheta.toFixed(2)}</td>
        <td>${percentile.toFixed(2)}</td>
      `;
      summaryTableBody.appendChild(summaryRow);

      // 종합 섹션 - 능력 분포 차트
      const ctxAbility = document
        .getElementById("abilityDistributionChart")
        .getContext("2d");

      // KDE를 사용하여 능력 분포 추정
      function kernelDensityEstimator(kernel, X) {
        return function (V) {
          return X.map(function (x) {
            return [
              x,
              math.mean(
                V.map(function (v) {
                  return kernel(x - v);
                })
              ),
            ];
          });
        };
      }
      function epanechnikovKernel(scale) {
        return function (u) {
          return Math.abs((u /= scale)) <= 1 ? (0.75 * (1 - u * u)) / scale : 0;
        };
      }

      const abilities = allExaminees.map((e) => e.overallTheta);
      const x = math
        .range(Math.min(...abilities) - 1, Math.max(...abilities) + 1, 0.1)
        .toArray();

      const kde = kernelDensityEstimator(epanechnikovKernel(0.5), x);
      const densityEstimates = kde(abilities);

      // 수험생의 위치 찾기
      let examineeY = 0;
      for (let i = 0; i < densityEstimates.length - 1; i++) {
        const x1 = densityEstimates[i][0];
        const x2 = densityEstimates[i + 1][0];
        if (overallTheta >= x1 && overallTheta <= x2) {
          const y1 = densityEstimates[i][1];
          const y2 = densityEstimates[i + 1][1];
          examineeY = y1 + ((overallTheta - x1) * (y2 - y1)) / (x2 - x1);
          break;
        }
      }

      const abilityChart = new Chart(ctxAbility, {
        type: "line",
        data: {
          labels: x,
          datasets: [
            {
              label: "능력 분포",
              data: densityEstimates.map((d) => d[1]),
              fill: true,
              backgroundColor: "rgba(75, 192, 192, 0.2)",
              borderColor: "rgba(75, 192, 192, 1)",
              pointRadius: 0,
            },
            {
              label: "당신의 위치",
              data: [{ x: overallTheta, y: examineeY }],
              type: "scatter",
              backgroundColor: "rgba(255, 99, 132, 1)",
              pointRadius: 8,
            },
          ],
        },
        options: {
          scales: {
            x: {
              type: "linear",
              position: "bottom",
              title: {
                display: true,
                text: "능력 추정치 (θ)",
              },
            },
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: "밀도",
              },
            },
          },
        },
      });

      // 필기 섹션 - 문항별 정답 및 난이도 테이블
      const questionDetailTableBodyWriting = document.querySelector(
        "#questionDetailTableWriting tbody"
      );

      const questionCodes = examinee.문항코드리스트.split(",");
      const correctnessList = examinee.OX리스트.split("");
      questionCodes.forEach((code, index) => {
        const question = df_questions.find(
          (q) => q.문항코드.toString() === code
        );
        if (question) {
          console.log(question);
          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${index + 1}</td>
            <td>${code}</td>
            <td>${correctnessList[index]}</td>
            <td>${Number(question.난이도).toFixed(2)}</td>
            <td>${Number(question.변별도).toFixed(2)}</td>
            <td>${question.평가영역}</td>
            <td>${question.평가항목}</td>
          `;
          questionDetailTableBodyWriting.appendChild(row);
        }
      });

      // 필기 섹션 - 문항 난이도와 정답 현황 차트
      const ctxDifficultyWriting = document
        .getElementById("difficultyChartWriting")
        .getContext("2d");

      const dataWriting = [];

      questionCodes.forEach((code, index) => {
        const question = df_questions.find(
          (q) => q.문항코드.toString() === code
        );
        if (question) {
          dataWriting.push({
            x: index + 1,
            y: question.난이도,
            correctness: correctnessList[index],
          });
        }
      });

      const correctDataWriting = dataWriting.filter(
        (d) => d.correctness === "O"
      );
      const incorrectDataWriting = dataWriting.filter(
        (d) => d.correctness === "X"
      );

      const difficultyChartWriting = new Chart(ctxDifficultyWriting, {
        type: "scatter",
        data: {
          datasets: [
            {
              label: "정답",
              data: correctDataWriting,
              backgroundColor: "rgba(75, 192, 192, 1)",
            },
            {
              label: "오답",
              data: incorrectDataWriting,
              backgroundColor: "rgba(255, 99, 132, 1)",
            },
          ],
        },
        options: {
          scales: {
            x: {
              title: {
                display: true,
                text: "문항 번호",
              },
              ticks: {
                stepSize: 1,
              },
            },
            y: {
              title: {
                display: true,
                text: "난이도",
              },
            },
          },
        },
      });

      // 필기 섹션 - 평가 영역별 성취도 테이블
      const areaPerformanceTableBodyWriting = document.querySelector(
        "#areaPerformanceTableWriting tbody"
      );

      const areaDataWriting = {};

      questionCodes.forEach((code, index) => {
        const question = df_questions.find(
          (q) => q.문항코드.toString() === code
        );
        if (question) {
          const area = question.평가영역;
          if (!areaDataWriting[area]) {
            areaDataWriting[area] = { total: 0, correct: 0 };
          }
          areaDataWriting[area].total += 1;
          if (correctnessList[index] === "O") {
            areaDataWriting[area].correct += 1;
          }
        }
      });

      Object.keys(areaDataWriting).forEach((area) => {
        const row = document.createElement("tr");
        const total = areaDataWriting[area].total;
        const correct = areaDataWriting[area].correct;
        const rate = ((correct / total) * 100).toFixed(2);
        row.innerHTML = `
          <td>${area}</td>
          <td>${total}</td>
          <td>${correct}</td>
          <td>${rate}</td>
        `;
        areaPerformanceTableBodyWriting.appendChild(row);
      });

      // 필기 섹션 - 평가 영역별 성취도 차트
      const ctxAreaPerformanceWriting = document
        .getElementById("areaPerformanceChartWriting")
        .getContext("2d");

      const areaLabelsWriting = Object.keys(areaDataWriting);
      const areaRatesWriting = areaLabelsWriting.map((area) =>
        (
          (areaDataWriting[area].correct / areaDataWriting[area].total) *
          100
        ).toFixed(2)
      );

      const areaChartWriting = new Chart(ctxAreaPerformanceWriting, {
        type: "bar",
        data: {
          labels: areaLabelsWriting,
          datasets: [
            {
              label: "정답률 (%)",
              data: areaRatesWriting,
              backgroundColor: "rgba(54, 162, 235, 0.5)",
            },
          ],
        },
        options: {
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              title: {
                display: true,
                text: "정답률 (%)",
              },
            },
          },
        },
      });

      // 필기 섹션 - 영역별 능력 프로파일 차트 추가
      const ctxAbilityProfileWriting = document
        .getElementById("abilityProfileChartWriting")
        .getContext("2d");

      const abilityProfileChartWriting = new Chart(ctxAbilityProfileWriting, {
        type: "radar",
        data: {
          labels: areaLabelsWriting,
          datasets: [
            {
              label: "필기 영역별 성취도 (%)",
              data: areaRatesWriting,
              backgroundColor: "rgba(75, 192, 192, 0.2)",
              borderColor: "rgba(75, 192, 192, 1)",
              pointBackgroundColor: "rgba(75, 192, 192, 1)",
            },
          ],
        },
        options: {
          scales: {
            r: {
              angleLines: {
                display: true,
              },
              suggestedMin: 0,
              suggestedMax: 100,
              ticks: {
                stepSize: 20,
              },
            },
          },
        },
      });

      // 구술 섹션 - 문항별 정답 및 난이도 테이블
      const questionDetailTableBodySpeaking = document.querySelector(
        "#questionDetailTableSpeaking tbody"
      );

      if (speakingData) {
        const speakingQuestionCodes = speakingData.문항코드리스트.split(",");
        const correctnessListSpeaking = speakingData.OX리스트.split("");
        speakingQuestionCodes.forEach((code, index) => {
          const question = df_questions_speaking.find(
            (q) => q.문항코드.toString() === code
          );
          if (question) {
            const row = document.createElement("tr");
            row.innerHTML = `
              <td>${index + 1}</td>
              <td>${code}</td>
              <td>${correctnessListSpeaking[index]}</td>
              <td>${Number(question.난이도).toFixed(2)}</td>
              <td>${Number(question.변별도).toFixed(2)}</td>
              <td>${question.평가영역}</td>
              <td>${question["평가종류"] || "-"}</td>
            `;
            questionDetailTableBodySpeaking.appendChild(row);
          }
        });
      } else {
        const row = document.createElement("tr");
        row.innerHTML = `<td colspan="7">구술 시험 데이터가 없습니다.</td>`;
        questionDetailTableBodySpeaking.appendChild(row);
      }

      // 구술 섹션 - 문항 난이도와 정답 현황 차트
      const ctxDifficultySpeaking = document
        .getElementById("difficultyChartSpeaking")
        .getContext("2d");

      const dataSpeaking = [];

      if (speakingData) {
        const speakingQuestionCodes = speakingData.문항코드리스트.split(",");
        const correctnessListSpeaking = speakingData.OX리스트.split("");
        speakingQuestionCodes.forEach((code, index) => {
          const question = df_questions_speaking.find(
            (q) => q.문항코드.toString() === code
          );
          if (question) {
            dataSpeaking.push({
              x: index + 1,
              y: question.난이도,
              correctness: correctnessListSpeaking[index],
            });
          }
        });

        const correctDataSpeaking = dataSpeaking.filter(
          (d) => d.correctness === "O"
        );
        const incorrectDataSpeaking = dataSpeaking.filter(
          (d) => d.correctness === "X"
        );

        const difficultyChartSpeaking = new Chart(ctxDifficultySpeaking, {
          type: "scatter",
          data: {
            datasets: [
              {
                label: "정답",
                data: correctDataSpeaking,
                backgroundColor: "rgba(75, 192, 192, 1)",
              },
              {
                label: "오답",
                data: incorrectDataSpeaking,
                backgroundColor: "rgba(255, 99, 132, 1)",
              },
            ],
          },
          options: {
            scales: {
              x: {
                title: {
                  display: true,
                  text: "문항 번호",
                },
                ticks: {
                  stepSize: 1,
                },
              },
              y: {
                title: {
                  display: true,
                  text: "난이도",
                },
              },
            },
          },
        });
      } else {
        ctxDifficultySpeaking.font = "16px Noto Sans KR";
        ctxDifficultySpeaking.fillText("구술 시험 데이터가 없습니다.", 50, 50);
      }

      // 구술 섹션 - 구술 시험 세부 평가 테이블
      if (speakingData) {
        const speakingDetailTableBody = document.querySelector(
          "#speakingDetailTable tbody"
        );
        const speakingQuestionCodes = speakingData.문항코드리스트.split(",");
        const speakingScores = speakingData.선택답안.split(",");
        speakingQuestionCodes.forEach((code, index) => {
          const question = df_questions_speaking.find(
            (q) => q.문항코드.toString() === code
          );
          const score = parseInt(speakingScores[index]);
          const criteriaList = speaking_grading_criteria.filter(
            (c) => c.문제번호.toString() === question.문제번호.toString()
          );

          // 수험생 점수에 해당하는 평가 기준 및 평가 기준 설명 찾기
          const criteria = criteriaList.find((c) => c.점수 === score);

          const row = document.createElement("tr");
          row.innerHTML = `
            <td>${question ? question.문제번호 : "-"}</td>
            <td>${question ? criteria["평가 목표"] : "-"}</td>
            <td>${score}</td>
            <td>${criteria ? criteria["평가 기준"] : "-"}</td>
            <td>${criteria ? criteria["평가 기준 설명"] : "-"}</td>
          `;
          speakingDetailTableBody.appendChild(row);
        });
      } else {
        document.querySelector("#speakingDetailTable").innerHTML =
          "<p>구술 시험 데이터가 없습니다.</p>";
      }

      // 구술 섹션 - 구술 시험 점수 분포 차트
      if (speakingData) {
        const ctxSpeakingScore = document
          .getElementById("speakingScoreDistributionChart")
          .getContext("2d");

        const speakingScoresAll = df_responses_speaking.map((d) =>
          parseInt(d.점수)
        );

        const yourScore = parseInt(speakingData.점수);

        // 점수 분포 계산
        const scoreCounts = {};
        speakingScoresAll.forEach((score) => {
          scoreCounts[score] = (scoreCounts[score] || 0) + 1;
        });

        const sortedScores = Object.keys(scoreCounts).sort((a, b) => a - b);
        const counts = sortedScores.map((score) => scoreCounts[score]);

        const yourScoreIndex = sortedScores.indexOf(yourScore.toString());

        const speakingScoreChart = new Chart(ctxSpeakingScore, {
          type: "bar",
          data: {
            labels: sortedScores,
            datasets: [
              {
                label: "수험생 수",
                data: counts,
                backgroundColor: sortedScores.map((score, index) =>
                  score == yourScore
                    ? "rgba(255, 99, 132, 0.5)"
                    : "rgba(75, 192, 192, 0.5)"
                ),
              },
            ],
          },
          options: {
            scales: {
              x: {
                title: {
                  display: true,
                  text: "점수",
                },
              },
              y: {
                title: {
                  display: true,
                  text: "수험생 수",
                },
              },
            },
          },
        });
      }

      // 구술 섹션 - 영역별 능력 프로파일 차트 추가
      if (speakingData) {
        const ctxAbilityProfileSpeaking = document
          .getElementById("abilityProfileChartSpeaking")
          .getContext("2d");

        // 구술 영역별 성취도 계산
        const areaDataSpeaking = {};

        const speakingQuestionCodes = speakingData.문항코드리스트.split(",");
        const correctnessListSpeaking = speakingData.OX리스트.split("");

        speakingQuestionCodes.forEach((code, index) => {
          const question = df_questions_speaking.find(
            (q) => q.문항코드.toString() === code
          );
          if (question) {
            const area = question.평가영역;
            if (!areaDataSpeaking[area]) {
              areaDataSpeaking[area] = { total: 0, correct: 0 };
            }
            areaDataSpeaking[area].total += 1;
            if (correctnessListSpeaking[index] === "O") {
              areaDataSpeaking[area].correct += 1;
            }
          }
        });

        const areaLabelsSpeaking = Object.keys(areaDataSpeaking);
        const areaRatesSpeaking = areaLabelsSpeaking.map((area) =>
          (
            (areaDataSpeaking[area].correct / areaDataSpeaking[area].total) *
            100
          ).toFixed(2)
        );

        const abilityProfileChartSpeaking = new Chart(
          ctxAbilityProfileSpeaking,
          {
            type: "radar",
            data: {
              labels: areaLabelsSpeaking,
              datasets: [
                {
                  label: "구술 영역별 성취도 (%)",
                  data: areaRatesSpeaking,
                  backgroundColor: "rgba(153, 102, 255, 0.2)",
                  borderColor: "rgba(153, 102, 255, 1)",
                  pointBackgroundColor: "rgba(153, 102, 255, 1)",
                },
              ],
            },
            options: {
              scales: {
                r: {
                  angleLines: {
                    display: true,
                  },
                  suggestedMin: 0,
                  suggestedMax: 100,
                  ticks: {
                    stepSize: 20,
                  },
                },
              },
            },
          }
        );
      } else {
        document.getElementById("abilityProfileChartSpeaking").remove();
        const speakingChartSection = document.querySelector(
          "#abilityProfileChartSpeaking"
        ).parentElement;
        speakingChartSection.innerHTML = "<p>구술 시험 데이터가 없습니다.</p>";
      }

      // 전체 정리 섹션 - 능력 추정치 비교 차트 (국적별)
      const ctxNationality = document
        .getElementById("nationalityComparisonChart")
        .getContext("2d");

      const nationalityData = {};

      allExaminees.forEach((e) => {
        const nat = e.국적;
        if (!nationalityData[nat]) {
          nationalityData[nat] = [];
        }
        nationalityData[nat].push(e.overallTheta);
      });

      const natLabels = Object.keys(nationalityData);
      const natMeans = natLabels.map(
        (nat) =>
          nationalityData[nat].reduce((a, b) => a + b, 0) /
          nationalityData[nat].length
      );

      // 수험생의 국적과 평균 능력 추정치 가져오기
      const examineeNationality = examinee.국적;

      const nationalityChart = new Chart(ctxNationality, {
        type: "bar",
        data: {
          labels: natLabels,
          datasets: [
            {
              label: "평균 능력 추정치 (θ)",
              data: natMeans,
              backgroundColor: natLabels.map((nat) =>
                nat === examineeNationality
                  ? "rgba(255, 99, 132, 0.5)"
                  : "rgba(153, 102, 255, 0.5)"
              ),
            },
          ],
        },
        options: {
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: "평균 능력 추정치 (θ)",
              },
              ticks: {
                callback: function (value) {
                  return value.toFixed(2);
                },
              },
            },
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function (context) {
                  let label = context.dataset.label || "";
                  if (label) {
                    label += ": ";
                  }
                  label += context.parsed.y.toFixed(2);
                  return label;
                },
              },
            },
          },
        },
      });

      // 전체 정리 섹션 - 추천 학습 방향 및 개선점
      const recommendation = document.getElementById("recommendation");

      // 필기와 구술 영역별 성취도 합산
      const totalAreaData = { ...areaDataWriting };
      if (speakingData) {
        const speakingQuestionCodes = speakingData.문항코드리스트.split(",");
        const correctnessListSpeaking = speakingData.OX리스트.split("");
        speakingQuestionCodes.forEach((code, index) => {
          const question = df_questions_speaking.find(
            (q) => q.문항코드.toString() === code
          );
          if (question) {
            const area = question.평가영역;
            if (!totalAreaData[area]) {
              totalAreaData[area] = { total: 0, correct: 0 };
            }
            totalAreaData[area].total += 1;
            if (correctnessListSpeaking[index] === "O") {
              totalAreaData[area].correct += 1;
            }
          }
        });
      }

      // 강점과 약점 파악
      const strengths = [];
      const weaknesses = [];

      Object.keys(totalAreaData).forEach((area) => {
        const rate =
          (totalAreaData[area].correct / totalAreaData[area].total) * 100;
        if (rate >= 80) {
          strengths.push(area);
        } else if (rate <= 50) {
          weaknesses.push(area);
        }
      });

      let recommendationText = `<strong>강점 영역:</strong> ${
        strengths.join(", ") || "없음"
      }<br>`;
      recommendationText += `<strong>개선이 필요한 영역:</strong> ${
        weaknesses.join(", ") || "없음"
      }<br>`;
      recommendationText += `앞으로 ${
        weaknesses.length > 0
          ? weaknesses.join(", ") + " 영역에 집중하여 학습하시길 권장드립니다."
          : "현재의 학습 방법을 유지하시길 바랍니다."
      }`;

      recommendation.innerHTML = recommendationText;
    </script>
  </body>
</html>
