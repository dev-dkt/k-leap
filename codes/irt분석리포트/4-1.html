<!DOCTYPE html>
<html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>한국어능력시험 정보 함수 분석 및 효율성 평가 보고서</title>
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="report-styles.css">
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <style>
            .heatmap-cell { stroke: #fff; }
            .heatmap-legend text { font-size: 10px; }
        </style>
    </head>
<body>
    <div class="container">
        <h1>한국어능력시험 정보 함수 분석 및 효율성 평가 보고서</h1>

        <div class="section">
            <h2>1. 요약</h2>
            <ul>
                <li>시험의 주요 측정 능력 범위: -0.5 ~ 1.0</li>
                <li>정보량 최대 지점: θ = 0.3 (정보량: 15.2)</li>
                <li>정보량 최소 지점: θ = -3.0 (정보량: 2.1)</li>
            </ul>

            <h3>주요 발견사항</h3>
            <ul>
                <li>시험은 중상위 수준의 능력을 가장 정확하게 측정하고 있습니다.</li>
                <li>극단적인 능력 수준(-3 이하, 3 이상)에서는 측정의 정확도가 낮습니다.</li>
                <li>응시자의 능력 분포와 시험 정보 함수 간에 약간의 불일치가 있습니다.</li>
                <li>읽기와 쓰기 영역이 다른 영역에 비해 더 많은 정보를 제공하고 있습니다.</li>
            </ul>
        </div>

        <div class="section">
            <h2>2. 시험 정보 함수 분석</h2>
            <div class="chart-container">
                <canvas id="tifChart"></canvas>
            </div>
            <p>시험 정보 함수는 능력 수준 θ = 0.3에서 최대값을 가지며, 이는 이 시험이 중상위 수준의 능력을 가장 정확하게 측정함을 의미합니다.</p>

            <h3>능력 수준별 정보량 히트맵</h3>
            <div id="heatmapChart"></div>
            <p>히트맵에서 볼 수 있듯이, 읽기와 쓰기 영역이 전반적으로 높은 정보량을 제공하고 있습니다. 반면, 말하기 영역은 상대적으로 낮은 정보량을 보이고 있습니다.</p>
        </div>

        <div class="section">
            <h2>3. 응시자 분포와의 일치도 분석</h2>
            <div class="chart-container">
                <canvas id="distributionChart"></canvas>
            </div>
            <p>응시자의 능력 분포와 시험 정보 함수 사이에 약간의 불일치가 관찰됩니다. 시험은 θ = 0.3 근처에서 가장 많은 정보를 제공하지만, 응시자의 능력 분포는 이보다 약간 낮은 구간에 집중되어 있습니다.</p>
        </div>

        <div class="section">
            <h2>4. 평가영역별 정보 제공 분석</h2>
            <div class="chart-container">
                <canvas id="domainInfoChart"></canvas>
            </div>
            <p>읽기와 쓰기 영역이 가장 많은 정보를 제공하고 있으며, 말하기 영역의 정보 제공량이 가장 적습니다. 이는 말하기 영역의 문항 개선이 필요함을 시사합니다.</p>
        </div>

        <div class="section">
            <h2>5. 개선 권고사항</h2>
            <h3>5.1 정보량 부족 구간 개선</h3>
            <ul>
                <li>극단적인 능력 수준(-3 이하, 3 이상)을 측정하는 문항 추가</li>
                <li>특히 고난도 문항(θ > 2)의 비중을 늘려 상위 능력 측정 정확도 향상</li>
            </ul>

            <h3>5.2 응시자 분포 일치도 향상</h3>
            <ul>
                <li>시험의 전반적인 난이도를 약간 낮추어 응시자 분포의 중심과 일치시킴</li>
                <li>θ = -0.5 ~ 0.5 구간의 문항 비중 증가</li>
            </ul>

            <h3>5.3 평가영역 간 균형 개선</h3>
            <ul>
                <li>말하기 영역의 문항 수 증가 또는 문항 품질 개선</li>
                <li>듣기 영역의 변별도 높은 문항 추가</li>
            </ul>
        </div>
    </div>

    <script type="module">
      import { df_irt, s_irt, df_questions,df_ability,df_responses  } from "./data.js";
    
      
  // 배열 index를 기준으로 df_responses와 df_ability 데이터를 합치는 함수
function mergeDataByIndex(df_responses, df_ability) {
    // 두 배열의 길이가 같다고 가정하고 index를 기준으로 병합
    const mergedData = df_responses.map((response, index) => {
      const ability = df_ability[index];
  
      // 이름이 같을 경우에만 데이터를 병합
      if (response.이름 === ability.이름) {
        return {
          ...response,
          "능력 추정치 (theta)": ability["능력 추정치 (theta)"],
        };
      } else {
        return response; // 이름이 다르면 기존 response 데이터 반환
      }
    });
  
    return mergedData;
  }
  console.log(df_responses.length)
  console.log(df_ability.length)
  // 두 데이터셋을 병합 실행
  const combinedData2 = mergeDataByIndex(df_responses, df_ability);
  
  // 병합된 데이터 확인
  console.log(combinedData2);

        // 능력 수준의 범위 설정
        const thetaRange = [-3, -2, -1, 0, 1, 2, 3];

        // TIF 계산 함수 (단순하게 각 문항의 변별도(alpha)를 가중치로 사용)
        function calculateTIF(theta) {
            return df_irt.reduce((totalInfo, item) => {
                const { "변별도 (alpha)": alpha, "난이도 (beta)": beta } = item;
                const info = alpha * Math.exp(-Math.pow(theta - beta, 2)); // 간단한 정보 함수 계산식 예시
                return totalInfo + info;
            }, 0);
        }

        // thetaRange에 대한 TIF 계산
        const tifData = thetaRange.map(theta => calculateTIF(theta));

        // 차트 데이터 및 옵션 (실제 데이터로 대체 필요)
        const tifChart = new Chart(
            document.getElementById('tifChart'),
            {
                type: 'line',
                data: {
                    labels: thetaRange,
                    datasets: [{
                        label: '시험 정보량',
                        data: tifData,
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: '시험 정보 함수'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '능력 수준 (θ)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '정보량'
                            }
                        }
                    }
                }
            }
        );
        // heatmapData를 생성하는 함수
        function createHeatmapData(df_irt, df_questions) {
            const heatmapData = [];

            // df_irt의 각 문항에 대해 평가영역을 매칭하고 heatmap 데이터를 구성
            df_irt.forEach(irtItem => {
                // df_questions에서 해당 문항 번호와 매칭되는 항목을 찾음
                const matchedQuestion = df_questions.find(question => question.문제번호 === irtItem["문항 번호"]);
                
                if (matchedQuestion) {
                    // heatmapData 객체 생성 (난이도 beta를 능력 수준으로 사용)
                    heatmapData.push({
                        ability: irtItem["난이도 (beta)"], // 능력 수준(θ)
                        domain: matchedQuestion["평가영역"], // 평가영역
                        value: irtItem["변별도 (alpha)"], // 변별도를 정보량으로 사용
                    });
                }
            });

            return heatmapData;
        }

        // D3.js를 사용한 히트맵 구현
 
        // heatmapData 생성
        const heatmapData = createHeatmapData(df_irt, df_questions);

        const margin = {top: 30, right: 30, bottom: 50, left: 70},
              width = 600 - margin.left - margin.right,
              height = 300 - margin.top - margin.bottom;

        const svg = d3.select("#heatmapChart")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const abilities = Array.from(new Set(heatmapData.map(d => d.ability)));
        const domains = Array.from(new Set(heatmapData.map(d => d.domain)));

        const x = d3.scaleBand()
            .range([0, width])
            .domain(abilities)
            .padding(0.01);

        const y = d3.scaleBand()
            .range([height, 0])
            .domain(domains)
            .padding(0.01);

        const color = d3.scaleSequential()
            .interpolator(d3.interpolateBlues)
            .domain([0, d3.max(heatmapData, d => d.value)]);  // 컬러 강도 상한선 조정
            
        svg.selectAll()
            .data(heatmapData)
            .enter()
            .append("rect")
            .attr("x", d => x(d.ability))
            .attr("y", d => y(d.domain))
            .attr("width", x.bandwidth())
            .attr("height", y.bandwidth())
            .style("fill", d => color(d.value))
            .attr("class", "heatmap-cell");

        svg.append("g")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(x).tickFormat(d => d))
            .append("text")
            .attr("x", width / 2)
            .attr("y", 40)
            .attr("fill", "black")
            .text("능력 수준 (θ)");

        svg.append("g")
            .call(d3.axisLeft(y))
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -50)
            .attr("x", -height / 2)
            .attr("fill", "black")
            .text("평가영역");

        const legendWidth = 200;
        const legendHeight = 20;

        const legendScale = d3.scaleLinear()
            .domain(color.domain())
            .range([0, legendWidth]);

        const legendAxis = d3.axisBottom(legendScale)
            .ticks(5)
            .tickFormat(d3.format(".1f"));

        const legend = svg.append("g")
            .attr("transform", `translate(${width - legendWidth}, ${height + 50})`);

        legend.append("g")
            .attr("class", "heatmap-legend")
            .call(legendAxis);

        legend.selectAll()
            .data(color.ticks(100))
            .enter().append("rect")
            .attr("x", d => legendScale(d))
            .attr("y", -legendHeight)
            .attr("width", (legendWidth / 100) + 1)
            .attr("height", legendHeight)
            .style("fill", color);

        legend.append("text")
            .attr("x", legendWidth / 2)
            .attr("y", -30)
            .style("text-anchor", "middle")
            .text("정보량");

        const distributionChart = new Chart(
            document.getElementById('distributionChart'),
            {
                type: 'bar',
                data: {
                    labels: [-3, -2, -1, 0, 1, 2, 3],
                    datasets: [{
                        type: 'bar',
                        label: '응시자 분포',
                        data: [1, 3, 7, 10, 6, 2, 1],
                        backgroundColor: 'rgba(255, 99, 132, 0.5)'
                    },
                    {
                        type: 'line',
                        label: '시험 정보량',
                        data: [2.1, 5, 10, 14, 15.2, 12, 6],
                        borderColor: 'rgb(75, 192, 192)',
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: '응시자 분포와 시험 정보 함수'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: '능력 수준 (θ)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: '응시자 수'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: '정보량'
                            }
                        }
                    }
                }
            }
        );
        // 평가영역별로 정보를 집계하여 평균 정보량을 계산하는 함수
        function calculateDomainInfo(df_irt, df_questions) {
            const domainInfo = {};

            // df_irt의 각 문항에 대해 평가영역을 매칭하고 정보량을 집계
            df_irt.forEach(irtItem => {
                // df_questions에서 해당 문항 번호와 매칭되는 항목을 찾음
                const matchedQuestion = df_questions.find(question => question.문제번호 === irtItem["문항 번호"]);
                
                if (matchedQuestion) {
                    const domain = matchedQuestion["평가영역"];
                    const alpha = irtItem["변별도 (alpha)"];
                    
                    // 해당 평가영역이 처음 나오면 초기화
                    if (!domainInfo[domain]) {
                        domainInfo[domain] = { totalAlpha: 0, count: 0 };
                    }
                    
                    // 변별도를 합산하고, 문항 수 증가
                    domainInfo[domain].totalAlpha += alpha;
                    domainInfo[domain].count += 1;
                }
            });

            // 평가영역별 평균 정보량 계산
            const domainAverages = Object.keys(domainInfo).map(domain => ({
                domain,
                averageAlpha: domainInfo[domain].totalAlpha / domainInfo[domain].count
            }));

            return domainAverages;
        }
        // 평가영역별 평균 정보량 계산
        const domainAverages = calculateDomainInfo(df_irt, df_questions);

        // Chart.js에 사용할 데이터 형식으로 변환
        const domainLabels = domainAverages.map(d => d.domain);
        const domainData = domainAverages.map(d => d.averageAlpha);

        // domainInfoChart 업데이트
        const domainInfoChart = new Chart(
            document.getElementById('domainInfoChart'),
            {
                type: 'bar',
                data: {
                    labels: domainLabels,
                    datasets: [{
                        label: '평균 정보량',
                        data: domainData,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: '평가영역별 평균 정보량'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: '평균 정보량'
                            }
                        }
                    }
                }
            }
        );
    </script>
</body>
</html>