<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>한국어능력시험 결과 기반 교육 프로그램 개선 가이드</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="report-styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>한국어능력시험 결과 기반 교육 프로그램 개선 가이드</h1>

      <div class="section">
        <h2>1. 능력 분포 개요</h2>
        <p>
          한국어능력시험 응시자의 능력 분포는 교육 프로그램 개선에 중요한 지표를
          제공합니다. 이 분포를 통해 학습자의 전반적인 수준과 편차를 파악할 수
          있으며, 이는 효과적인 교육 전략 수립의 기초가 됩니다.
        </p>
        <canvas id="ability-distribution"></canvas>
      </div>

      <div class="section">
        <h2>2. 학습자 그룹별 능력 분포 분석</h2>
        <canvas id="group-analysis"></canvas>
      </div>

      <div class="section">
        <h2>3. 강점 및 약점 영역 식별</h2>
        <div id="strength-weakness"></div>
      </div>

      <div class="section">
        <h2>4. 교육 프로그램 효과성 평가</h2>
        <div id="program-effectiveness"></div>
      </div>

      <div class="section">
        <h2>5. 맞춤형 교육 전략 수립</h2>
        <div id="education-strategy"></div>
      </div>
    </div>

    <footer>
      <p>
        본 프로파일은 2024년 9월 기준으로 작성되었습니다. 향후 시험 정책 변경에
        따라 내용이 수정될 수 있습니다.
      </p>
    </footer>
    <script type="module">
      import {
        df_questions as _df_questions,
        df_responses,
        df_questions_speaking as _df_questions_speaking,
        df_responses_speaking,
        speaking_grading_criteria,
      } from "./data2.js";

      const df_questions = _df_questions.map((q) => {
        q.난이도 = parseFloat(q.난이도);
        q.변별도 = parseFloat(q.변별도);
        return q;
      });
      const df_questions_speaking = _df_questions_speaking.map((q) => {
        q.난이도 = parseFloat(q.난이도);
        q.변별도 = parseFloat(q.변별도);
        return q;
      });
      // 유효한 숫자인지 확인하는 함수
      function isValidNumber(n) {
        return typeof n === "number" && !isNaN(n) && isFinite(n);
      }

      // 능력 분포 개요 (Chart.js 사용)
      const abilities = df_responses
        .map((r) => parseFloat(r["능력 추정치 (theta)"]))
        .filter(isValidNumber);

      const ctx = document
        .getElementById("ability-distribution")
        .getContext("2d");

      // 히스토그램 데이터 생성
      const binCount = 20;
      const histogramData = d3
        .histogram()
        .domain(d3.extent(abilities))
        .thresholds(binCount)(abilities);

      new Chart(ctx, {
        type: "bar",
        data: {
          labels: histogramData.map((d) => d.x0.toFixed(2)),
          datasets: [
            {
              label: "빈도",
              data: histogramData.map((d) => d.length),
              backgroundColor: "rgba(105, 179, 162, 0.5)",
              borderColor: "rgba(105, 179, 162, 1)",
              borderWidth: 1,
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            x: {
              title: {
                display: true,
                text: "능력 추정치 (θ)",
              },
            },
            y: {
              title: {
                display: true,
                text: "빈도",
              },
              beginAtZero: true,
            },
          },
          plugins: {
            title: {
              display: true,
              text: "한국어능력시험 응시자 능력 분포",
            },
          },
        },
      });

      // 학습자 그룹별 능력 분포 분석 (Chart.js 사용)
      const koreanLevels = [
        ...new Set(df_responses.map((r) => r["한국어 수준"])),
      ];
      const levelData = koreanLevels
        .map((level) => {
          const levelAbilities = df_responses
            .filter((r) => r["한국어 수준"] === level)
            .map((r) => parseFloat(r["능력 추정치 (theta)"]))
            .filter(isValidNumber);
          return {
            level,
            mean: d3.mean(levelAbilities) || 0,
          };
        })
        .filter((d) => isValidNumber(d.mean));

      const ctxGroup = document
        .getElementById("group-analysis")
        .getContext("2d");

      new Chart(ctxGroup, {
        type: "bar",
        data: {
          labels: levelData.map((d) => `수준 ${d.level}`),
          datasets: [
            {
              label: "평균 능력 추정치",
              data: levelData.map((d) => d.mean),
              backgroundColor: "rgba(105, 179, 162, 0.5)",
              borderColor: "rgba(105, 179, 162, 1)",
              borderWidth: 1,
            },
          ],
        },
        options: {
          responsive: true,
          scales: {
            x: {
              title: {
                display: true,
                text: "한국어 수준",
              },
            },
            y: {
              title: {
                display: true,
                text: "평균 능력 추정치 (θ)",
              },
              beginAtZero: true,
            },
          },
          plugins: {
            title: {
              display: true,
              text: "한국어 수준별 평균 능력 추정치",
            },
          },
        },
      });

      // 강점 및 약점 영역 데이터 계산
      const areaScores = df_questions.reduce((acc, q) => {
        if (!acc[q.평가영역]) {
          acc[q.평가영역] = { total: 0, count: 0 };
        }
        acc[q.평가영역].total += q.난이도;
        acc[q.평가영역].count += 1;
        return acc;
      }, {});

      const areaScoresArray = Object.entries(areaScores).map(
        ([area, data]) => ({
          area,
          score: data.total / data.count,
        })
      );

      // 레이더 차트 설정
      const radarWidth = 600;
      const radarHeight = 600;
      const radarRadius = Math.min(radarWidth, radarHeight) / 2 - 100;

      const radarSvg = d3
        .select("#strength-weakness")
        .append("svg")
        .attr("width", radarWidth)
        .attr("height", radarHeight)
        .append("g")
        .attr("transform", `translate(${radarWidth / 2},${radarHeight / 2})`);

      // 스케일 조정: 최소값과 최대값을 사용하여 범위 설정
      const scoreExtent = d3.extent(areaScoresArray, (d) => d.score);
      const maxAbsValue = Math.max(
        Math.abs(scoreExtent[0]),
        Math.abs(scoreExtent[1])
      );
      const radarScale = d3
        .scaleLinear()
        .domain([-maxAbsValue, maxAbsValue])
        .range([0, radarRadius]);

      const angleSlice = (Math.PI * 2) / areaScoresArray.length;

      // 그리드 라인 추가
      const gridLevels = 5;
      const gridStep = (2 * maxAbsValue) / gridLevels;
      for (let j = 0; j <= gridLevels; j++) {
        const gridValue = -maxAbsValue + j * gridStep;
        const gridRadius = radarScale(gridValue);
        radarSvg
          .append("circle")
          .attr("cx", 0)
          .attr("cy", 0)
          .attr("r", gridRadius)
          .style("fill", "none")
          .style("stroke", "#CDCDCD")
          .style("stroke-dasharray", "4 4");

        radarSvg
          .append("text")
          .attr("x", 5)
          .attr("y", -gridRadius)
          .text(gridValue.toFixed(2))
          .style("font-size", "10px")
          .style("fill", "#666");
      }

      // 축 추가
      areaScoresArray.forEach((d, i) => {
        const angle = i * angleSlice;
        const lineX = radarRadius * Math.cos(angle - Math.PI / 2);
        const lineY = radarRadius * Math.sin(angle - Math.PI / 2);

        radarSvg
          .append("line")
          .attr("x1", 0)
          .attr("y1", 0)
          .attr("x2", lineX)
          .attr("y2", lineY)
          .style("stroke", "#999")
          .style("stroke-width", "1px");

        const labelX = 1.15 * radarRadius * Math.cos(angle - Math.PI / 2);
        const labelY = 1.15 * radarRadius * Math.sin(angle - Math.PI / 2);

        radarSvg
          .append("text")
          .attr("x", labelX)
          .attr("y", labelY)
          .text(d.area)
          .style("font-size", "12px")
          .style("text-anchor", "middle")
          .attr("dy", "0.35em");
      });

      // 데이터 포인트 그리기
      const radarLine = d3
        .lineRadial()
        .radius((d) => radarScale(d.score))
        .angle((d, i) => i * angleSlice);

      radarSvg
        .append("path")
        .datum(areaScoresArray)
        .attr("d", radarLine)
        .style("fill", "rgba(255, 99, 132, 0.2)")
        .style("stroke", "rgb(255, 99, 132)")
        .style("stroke-width", "2px");

      // 데이터 포인트에 원 추가
      radarSvg
        .selectAll(".radarCircle")
        .data(areaScoresArray)
        .enter()
        .append("circle")
        .attr("class", "radarCircle")
        .attr("r", 4)
        .attr(
          "cx",
          (d, i) => radarScale(d.score) * Math.cos(angleSlice * i - Math.PI / 2)
        )
        .attr(
          "cy",
          (d, i) => radarScale(d.score) * Math.sin(angleSlice * i - Math.PI / 2)
        )
        .style("fill", "rgb(255, 99, 132)")
        .style("stroke", "#fff")
        .style("stroke-width", "2px");

      // 데이터 값 표시
      radarSvg
        .selectAll(".radarValue")
        .data(areaScoresArray)
        .enter()
        .append("text")
        .attr("class", "radarValue")
        .attr(
          "x",
          (d, i) =>
            1.1 * radarScale(d.score) * Math.cos(angleSlice * i - Math.PI / 2)
        )
        .attr(
          "y",
          (d, i) =>
            1.1 * radarScale(d.score) * Math.sin(angleSlice * i - Math.PI / 2)
        )
        .text((d) => d.score.toFixed(2))
        .style("font-size", "10px")
        .style("fill", "#333")
        .style("text-anchor", "middle");

      // 교육 프로그램 효과성 평가
      const averageScore = d3.mean(df_responses.map((r) => parseFloat(r.점수)));
      const speakingScore = d3.mean(
        df_responses_speaking.map((r) => parseFloat(r.점수))
      );

      document.getElementById("program-effectiveness").innerHTML = `
        <p>현재 데이터를 기반으로 한 교육 프로그램의 효과성 평가:</p>
        <ul>
          <li>전체 평균 점수: ${averageScore.toFixed(2)}</li>
          <li>말하기 평균 점수: ${speakingScore.toFixed(2)}</li>
        </ul>
        <p>추가적인 프로그램 효과성 평가 방법:</p>
        <ul>
          <li>정기적인 능력 평가 실시 및 결과 추적</li>
          <li>학습자 피드백 수집 및 분석</li>
          <li>한국어 수준별 성취도 비교 분석</li>
        </ul>
      `;

      // 맞춤형 교육 전략 수립
      const weakestArea = areaScoresArray.reduce(
        (min, p) => (p.score < min.score ? p : min),
        areaScoresArray[0]
      );
      const strongestArea = areaScoresArray.reduce(
        (max, p) => (p.score > max.score ? p : max),
        areaScoresArray[0]
      );

      document.getElementById("education-strategy").innerHTML = `
        <h3>수준별 학습 전략</h3>
        <ul>
          <li>초급 (수준 1-2): 기초 어휘 및 문법 강화, 일상 회화 중심 학습</li>
          <li>중급 (수준 3-4): 다양한 상황별 의사소통 능력 향상, 읽기 및 쓰기 능력 강화</li>
          <li>고급 (수준 5-6): 학술적, 전문적 한국어 사용 능력 개발, 문화적 이해 심화</li>
        </ul>
        <h3>약점 영역 보완을 위한 커리큘럼 조정 방안</h3>
        <ul>
          <li>${weakestArea.area} 영역 강화: 추가 학습 자료 제공, 개별 지도 시간 확대</li>
          <li>균형 잡힌 커리큘럼: 모든 영역의 균형적 발전을 위한 통합적 접근 방식 채택</li>
          <li>실전 연습 확대: 시험 유형에 맞춘 모의고사 및 피드백 세션 정기 실시</li>
        </ul>
        <h3>강점 활용 전략</h3>
        <ul>
          <li>${strongestArea.area} 영역 활용: 다른 영역 학습에 강점 영역의 지식과 기술 접목</li>
          <li>멘토링 프로그램: 강점 영역에서 우수한 학생들이 다른 학생들을 돕는 체계 구축</li>
        </ul>
        <h3>구술 평가 개선 전략</h3>
        <ul>
          <li>말하기 연습 강화: 일대일 회화 세션 및 그룹 토론 활동 증가</li>
          <li>발음 클리닉: 개인별 발음 교정 및 개선 프로그램 운영</li>
          <li>문화 통합 말하기: 한국 문화 주제를 활용한 말하기 과제 부여</li>
        </ul>
      `;
    </script>
  </body>
</html>
